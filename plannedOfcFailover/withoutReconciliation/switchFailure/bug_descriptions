Bug#1 (deadlock in Failover): Failover module receives the failover request and sends FAILOVER_INIT signal to OFC1 → 
RCS Sequencer schedules an IR for sw0 → OFC1 NIB event handler receives the notification and schedules the role update 
request for sw0 → OFC0 NIB event handler receives the notification for the new IR and passes the IR to workers → OFC0 
worker forwards the IR to sw0 → sw0 receives the IR, successfully installs the IR, and sends the confirmation to OFC0 
→ sw0 CPU fails → OFC0 changes the flag of IR to IR_DONE → sw0 CPU recovers →  OFC0 topo event handler receives the 
notification about sw0 failure and suspends the sw0 (both in NIB, and its local) → OFC1 worker does not forward the 
role-req since its switch is suspended


+ Problem: The problem is Failover is not finished successfully since OFC1 is waiting for all the switches to have 
ROLE_EQUAL. 

+ Solution: OFC1 should skip failed switches, and get back to them when they are recovered. The OF event handler upon 
recovery of a switch checks if it is the master of the switch or not. If it is not, it schedules a role update msg to 
update its role to ROLE_MASTER.  
======================================================================================================================
======================================================================================================================
Bug#2 (permission and synchronizatoin issue): Failover module receives the failover request and sends the FAILOVER_INIT 
signal to OFC1 → OFC1 NIB event handler receives the notification and schedules the role update request for sw0 → OFC1 
worker forwards the role request (ROLE_EQUAL) msg to sw0 → sw0 receives the packet → sw0 CPU fails → OFC1 OpenFlow 
event handler receives the event and suspends the switch (both in NIB and its local) → sw0 CPU recovers → OFC1 NIB 
event handler skips role update in sw0 as it is suspended, synchronizes its local IRQueue with IRQueue in NIB and 
changes its failover status to FAILOVER_READY → failover module receives the notification and sends FAILOVER_TERMINATE
signal to OFC0 → OFC0 NIB event handler sends termination signal to workers, and they terminate gracefully → OFC1 
OpenFlow event handler receives the switch recovery event → Since its role in switch is ROLE_SLAVE, OFC1 OpenFlow 
event handler schedules a role update request msg (ROLE_MASTER) → OFC1 worker forwards the role request msg to sw0 → 
sw0 updates the roles (OFC1 |→ ROLE_MASTER, OFC0 |→ ROLE_SLAVE) and replies with confirmation msg → OFC0 NIB event 
handler processes the sw failure event and changes the switch status to SW_SUSPEND → OFC1 monitoring server receives 
the role update confirmation msg and updates its role in NIB to ROLE_MASTER → OFC0 NIB event handler sends termination 
signal to monitoring server and OF event handler, and they terminate. → OFC0 NIB event handler changes its failover 
status in NIB to FAILOVER_TERMINATE_DONE → Failover module changes OFC roles in NIB

+ Problem: IR is not installed in the switch since the status of the sw is SW_SUSPEND in NIB while the switch is 
actually working correctly. 

+ Solution: Only the master OFC should be able to make topology modifications and needs a way to synchronize the 
events between different OFCs. 
====================================================================================================================
====================================================================================================================
EVENT SYN -- Alg#1: slave OFC OpenFlow event handler is initially sleep, and does not process any event. During the 
failover, and before OFC NIB event handler sends FAILOVER_READY signal to failover module, OFC NIB event handler 
synchronizes its internal event log, internal topology with NIB’s, and wakes up the OFC OpenFlow event handler.

Bug#3 (event more than once): Failover module receives the failover request and sends FAILOVER_INIT signal to OFC1 → 
OFC1 NIB event handler receives the notification and schedules role update msg → OFC1 worker forwards the role update 
msg (ROLE_EQUAL) → sw0 updates OFC1’s role and sends back the confirmation → sw0 CPU fails → OFC0 OF event handler 
receives the event and suspends the switch → OFC1 monitoring server receives the ROLE_REPLY msg → OFC1 NIB event 
handler subscribe to IRQueue and synchronizes its local IRQueue with NIB’s →OFC1 NIB event handler wakes up the OFC 
OpenFlow → sw0 CPU recovers →  sw0 CPU recovers → OFC0 OF event handler processes the event and changes flag of sw to 
SW_RUN (both locally and in NIB) → OFC1 OF event handler receives the recovery event and processes it.

+ Problem: Recovery event is processed twice. 
+ Solution: OFC1 should not start processing the events until an OFC2 is terminated.
====================================================================================================================
==================================================================================================================== 
EVENT SYN -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events. 
Bug#4 (IR by two OFCs): RCS Sequencer schedules an IR for sw0 → Failover module receives the failover request and 
sends FAILOVER_INIT signal to OFC1 → OFC0 NIB event handler receives the IR and passed the IR to workers → OFC1 NIB 
event handler receives the notification and schedules a ROLE_REQ msg to update switches’s role to ROLE_EQUAL → OFC0 
worker changes the flag of IR to IR_SENT and forwards the IR to switch → sw0 installs the IR but its cpu fails before 
sending the confirmation → sw0 CPU recovers → OFC0 OpenFlow event handler processes the failure event and suspends 
the switch → OFC1 worker sends the role request msg → sw0 updates the role and sends back role reply msg → OFC1 
monitoring server receives the confirmation → OFC1 NIB event handler subscribes to IRQueue and synchronizes its local 
IRQueue with NIB’s → OFC1 sends FAILOVER_READY signal to failover module → OFC0 OpenFlow event handler processes 
the recovery event and changes the switch status to SW_RUN → OFC0 OpenFlow event handler changes the flag of IR to 
IR_NONE as it has not received any confirmation → OFC1 worker changes the status of IR to IR_SENT and forward the 
IR (this is because earlier OFC1 NIB event handler synchronized the local queue of OFC with NIB’s queue, and as a 
result, IR is inside the local IR Queue. Then, as the flag of IR is IR_NONE, the worker forwards the IR) → switch 
receives the IR and install the IR for the second time.  

+ Problem: IR is installed twice by two different OFCs. 
+ Solution: OFC NIB event handler should fetch the IRs from NIB IRQueue before sending the FAILOVER_READY signal to 
the Failover module. However, it should pass the IRs to the workers after the failover is done, and this OFC is the 
new master OFC. 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events. 
Bug#5 (deadlock in failover): Failover module receives the failover request and sends FAILOVER_INIT signal to OFC1 
→ OFC1 NIB event handler receives the notification and schedule a ROLE_REQ msg to update its role to ROLE_EQUAL → 
RCS sequencer schedules an IR → OFC0 NIB event handler receives the IR and passes the IR to workers → OFC0 worker 
forwards the IR to the switch → sw0 CPU fails before installing the IR → OFC0 event handler processes the failure 
event and suspends the switch → sw0 CPU recovers → OFC1 forwards the role request msg to the switch → sw0 updates 
the role and replies with ROLE_REPLY → OFC1 monitoring server receives the role reply msg → OFC1 NIB event handler 
subscribes to NIB IR Queue, pulls the NIB IRQueue, and sends FAILOVER_READY signal to the failover module → failover 
module sends termination signal to OFC0 → OFC0 NIB event handler receives the notification and sends TERMINATE_INIT 
signal to the workers → OFC0 workers terminate gracefully → OFC0 NIB event handler sends TERMINATE_INIT to monitoring 
server and OpenFlow event handler → OFC0 OpenFlow event handler terminates gracefully → OFC0 monitoring server waits 
to receive the ACK for IR (which has IR_SENT status), and rejects to terminate

+ Problem: Deadlock in failover 
+ Solution: monitoring server should terminate and not wait for the IRs with IR_SENT status corresponding to switches 
with SW_SUSPEND flag. 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events. 
Bug#6 (deadlock in failover): Failover module receives the failover request and sends FAILOVER_INIT signal to OFC1 →  
OFC1 NIB event handler receives the notification and schedule ROLE_REQ msg to update its role to ROLE_EQUAL → 
Sequencer schedules an IR → OFC0 NIB event handler receives the IR and passes to the workers → OFC1 worker forwards 
the role request to sw0 → sw0 CPU fails before updating the role → OFC0 OpenFlow event handler processes the failure 
event and suspends the switch → OFC0 worker does not forward the IR since the corresponding switch is suspended → sw0 
CPU recovers → OFC0 OpenFlow event handler processes the recovery event and changes the status of switch to SW_RUN → 
Sequencer reschedules the IR → OFC0 NIB event handler receives and passes the IR to workers → OFC0 worker forwards 
the IR to switch → switch installs the IR and sends back the confirmation → OFC0 monitoring server receives the 
confirmation and changes the flag of IR to IR_DONE

+ Problem: Deadlock in failover as OFC1 NIB event handler thinks the switch is up and waits for role reply msg. 
However, the switch has lost the role reply msg during the failure. 
+ Solution: OFC1 NIB event handler should subscribe to the SwSuspension status before scheduling the ROLE_REQ massages. 
As a result, it will receive every notification regarding topology change, and modifies the locally maintained 
topology state accordingly.
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events. 
Bug#7 (deadlock in failover): failover module receives the request and sends the FAILOVER_INIT to OFC1 → RCS 
Sequencer schedules an IR → OFC0 NIB event handler receives and passes the IR to workers →OFC0 worker forwards the 
IR →sw0 CPU fails before installing the IR and the IR is lost → OFC1 failover handler receives the FAILOVER_INIT 
notification and subscribes to the NIB topology changes → sw0 CPU recovers → OFC1 failover handler schedule role req 
msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg → sw0 updates the role and responds with ROLE_REPLY → 
OFC1 monitoring server receives and processes the ROLE_REPLY → OFC1 NIB event handler subscribes to NIB IR Queue and 
pulls the IRs in NIB IR Queue. It, then, sends a FAILOVER_READY signal to the failover module → Failover module sends 
a FAILOVER_TERMINATE signal to the OFC0 → OFC0 failover module sends TERMINATE_INIT signal to the workers → OFC0 
workers terminate gracefully → OFC0 failover module sends TERMINATE_INIT signal to the monitoring server and OF event 
handler → OFC0 OF event handler terminates → OFC0 monitoring server reject to terminate as it is waiting for the 
acknowledgement of the IR (has IR_SENT flag corresponding to a switch with SW_RUN state) 

+ Problem: Deadlock in Failover  
+ Solution: OFC failover handler should first gracefully terminate the monitoring server and then, terminate the OF 
event handler. 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events. 
Bug#8 (deadlock in Failover): Failover module receives the failover request and sends the FAILOVER_INIT to OFC1 → 
Sequencer schedules an IR → OFC0 NIB event handler receives and passes the IR to workers → OFC0 worker forwards the 
IR → sw0 receives and installs the IR, and sends back the confirmation → sw0 CPU fails → OFC0 OF event handler 
processes the failure event and suspends the switch → OFC0 monitoring server receives the confirmation and changes 
the flag of IR to IR_DONE → OFC1 failover handler receives the notification and subscribes to the topology changes 
→  OFC1 failover handler schedules role req msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg → the 
ROLE_REQ msg is lost since the switch is failed → sw0 CPU recovers → OFC0 OF event handler processes the switch 
recovery event and changes the state of switch to SW_RUN → OFC1 NIB event handler receives the TOPO_MOD event 
(switch status changed to SW_RUN) → OFC1 NIB event handler does not do anything because the previous state of 
switch was SW_RUN and the event states that the switch status has to be changed to SW_RUN 
   
+ Problem: Deadlock in failover as OFC1 Failover handler waits for the ROLE_REPLY msg forever. It is because OFC1 
does not know about the switch failure event.
+ Solution: OFC1 failover should pull the topology state from the NIB after subscribing to the topology changes. 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events
Bug#9 (deadlock in failover): Failover module receives the failover request and sends the FAILOVER_INIT to OFC1 → 
OFC1 failover handler receives the signal, subscribes to and pull the topology state from NIB → OFC1 failover module 
schedules ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg → sw0 CPU fails before updating the 
roles → OFC0 OF event handler processes the switch failure event and suspends the switch → sw0 CPU recovers → OFC1 
NIB event handler receives the TOPO_MOD event (sw0 |-> suspend) and modifies the internal topology state → OFC1 
failover module thinks the switch is failed and sends FAILOVER_READY signal to the failover module → OFC0 OF event 
handler processes the switch recovery event and changes the state of switch to SW_RUN → NIB event handler receives 
the topology change event (sw0 |-> run) and modifies topology state, but since its failover status is no longer in 
FAILOVER_INIT, it does not reschedule the ROLE_REQ → OFC0 OF event handler changes the flag of IR to IR_NONE since 
OFC has not received the confirmation for the IR → failover module sends FAILOVER_TERMINATE to OFC0 → OFC0 failover 
handler receives the signal and sends termination signal to workers → Sequencer schedules an IR → OFC1 NIB event 
handler passes the IR to the workers → OFC1 worker changes the flag of IR to IR_SENT in NIB and forwards the IR → 
switch rejects the IR and replies with bad request error (OFC1’s role is ROLE_SLAVE) → OFC0 worker terminates → 
OFC1 monitoring server receives the bad request and does not do anything → OFC0 monitoring server reject to 
terminate as IR status in NIB is IR_SENT (set by OFC1) corresponding to a switch with status SW_RUN
+ Problem: deadlock in failover as OFC0 monitoring server rejects to terminate and waits for the confirmation of the 
IR
+ Solution: OFC1 NIB event handler should not pass the IRs to the worker until it becomes the master OFC. 
(Same problem happened previously where only one module was handling responsibilities of both NIB event handler and 
Failover handler.) 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#2: slave OFC OpenFlow event handler is initially sleep, and does not process any event. After the 
OFC role is completely transferred to the OFC, its NIB event handler wakes up the OpenFlow event handler to start 
processing the events
Bug#10 (reconciliation between NIB and OFC): Failover module receives the failover request and sends the FAILOVER_INIT 
to OFC1 → OFC1 failover handler receives the signal, subscribes to and pull the topology state from NIB → OFC1 
failover module schedules ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg → sw0 updates the role 
and responds with ROLE_REPLY → sw0 CPU fails → OFC1 monitoring server receives the ROLE_REPLY → OFC1 failover handler 
subscribes to and fetches the IRs from the NIB IRQueue, and then changes its failover status to FAILOVER_READY → 
Failover module receives the notification and sends FAILOVER_TERMINATE signal to OFC0 → sw0 CPU recovers → OFC0 
failover handler receives the notification and sends termination signal to the workers → OFC0 worker terminates → 
OFC0 failover handler sends termination signal to the monitoring server → OFC0 OF event handler processes the failure 
event and suspends the switch → OFC0 monitoring server terminates → OFC0 failover handler sends termination signal to 
the OF event handler → OFC0 OF event handler terminates → OFC0 failover handler changes its status to 
FAILOVER_TERMINATE_DONE → Failover module receives the termination signal and changes the roles (OFC0 |-> slave, 
OFC1 |-> master) → OFC1 failover handler initializes and wakes up the OF event handler → OFC1 failover handler 
schedules ROLE_REQ (to ROLE_MASTER) → OFC1 NIB event handler processes the TOPO_MOD event (sw0 -> suspend) and suspends 
the switch locally) → OFC1 worker forwards the ROLE_REQ msg to the switch → sw0 updates the role and sends back 
ROLE_REPLY → OFC1 monitoring server receives the ROLE_REPLY msg
+ Problem: Sequencer does not schedule any IR since the state of the switch in NIB is SW_SUSPENDED while the switch 
is actually working fine. 
+ Solution: we should have an event log inside a NIB as a descriptor of how the current state of NIB is constructed. 
Then, when initializing the OFC1’s OF event handler, instead of discarding all the events, OFC1 failover handler should 
reconcile the internally received events with the NIB’s event log. 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#3: 
-- (Slave Part) Slave OFC OpenFlow event handler initially does not process any events (only adds them to the local 
event log. After the OFC role is completely transferred to the OFC, its NIB event handler synchronizes the internal 
event log with NIB’s event log. Then, it wakes up the OF event handler. 
-- (Master Part) Master OFC adds the events to the NIB event log after completely processing an IR. Only the master 
OFC has write access to NIB event log. 
RECONCIL NIB & LOCAL EVENT LOG -- Alg#1: Sequentially go through the event logs and find the events in local event 
logs that are not inside the NIB log file. For every switch, two cases might happen, either NIB event log is a head 
of local event log or vice versa. If the former happens, the OF event handler should discard some of the events that 
it is going to receive. In the latter case, the OF event handler should process those events and update the NIB. 
Finally, empty the OF event handler’s queue and fill it with these unprocessed events.

Bug#11 (OF event handler exception): OFC1 OF event handler read an event from its event queue. However, before OFC1 
OF event handler removes the event from the head of queue, OFC1 failover handler reconciles the event logs, and empties 
the OF event handler’s queue. Therefore, the event handler encounters an exception. 
+ Solution: failover handler should make sure OF event handler is not in the middle of processing an event, and 
prohibits OF event handler from starting to process an event. 
====================================================================================================================
====================================================================================================================
Bug#12 (Wrong event insertion to NIB event log): 
Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
receives the notification, subscribes to the topology, and pulls the topology state from NIB → OFC1 failover handler 
schedules ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch → sw0 CPU fails before 
updating the roles → sw0 CPU recovers → OFC0 OF event handler processes the failure event and suspends the switch → 
OFC1 NIB event handler receives the TOPO_MOD notif and suspends the switch in local directory → OFC1 failover handler 
subscribes to NIB IRQueue, fetches the IRs from the NIB’s IRQueue and changes its failover state to FAILOVER_READY 
(sw0 is suspended so jump from it) → OFC0 OF event handler adds the failure event to the local event log and NIB 
event log →failover module receives FAILOVER_READY from OFC1 and sends FAILOVER_TERMINATE to OFC0 → OFC0 failover 
handler sends termination signal to the workers → OFC0 workers terminate → OFC0 failover handler sends termination 
signal to the monitoring server → OFC0 monitoring server terminates → OFC0 failover handler sends termination signal 
to the OF event handler → OFC0 OF event handler terminates → OFC0 failover handler changes its failover status to 
FAILOVER_TERMINATE_DONE and self terminates → failover module changes the role of OFC0 to slave and OFC1 to master 
→ OFC1 OF event handler adds the failure event to both the local and NIB event log (OFC1 is the master and has write 
access to NIB event log) → OFC1 OF event handler adds the recovery event to both the local and the NIB event log → 
OFC1 failover handler receives the notification of becoming the master and passes the fetched IRs to the workers 
(None in this case)

+ Problem: Wrong event log in NIB
NIB event log = [sw0 -> failed, sw0 -> failed, sw0 -> suspended]
NIBSwSuspensionStatus = [sw -> SW_SUSPEND]
The seconds and third event added to the NIB event log are added without being processed by OFC1 and before failover 
module performing the event reconciliation. 
+ Solution: OFC1 should not add the unprocessed events to the NIB event log. 
====================================================================================================================
====================================================================================================================
Bug#13 (emptying event queue error): 
Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler receives 
the notification, subscribes to the topology, and pulls the topology state from NIB → OFC1 failover handler schedules 
ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch → sw0 updates the role and responds 
with ROLE_REPLY → sw0 CPU fails → OFC0 OF event handler processes the failure event and suspends the switch (both in 
NIB and locally) → sw0 CPU recovers → OFC0 OF event handler adds the failure event to NIB event log and local event log 
→ OFC1 monitoring server receives the ROLE_REPLY →  OFC1 failover handler subscribes to NIB IRQueue, fetches the IRs from 
the NIB’s IRQueue and changes its failover state to FAILOVER_READY → failover module receives FAILOVER_READY from OFC1 
and sends FAILOVER_TERMINATE to OFC0 → OFC0 failover handler sends termination signal to the workers → OFC0 workers 
terminate → OFC0 failover handler sends termination signal to the monitoring server → OFC0 monitoring server terminates 
→ OFC0 failover handler sends termination signal to the OF event handler → OFC0 OF event handler terminates → OFC0 
failover handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates → failover module changes 
the role of OFC0 to slave and OFC1 to master → OFC1 failover handler receives the notification of becoming the master 
and passes the fetched IRs to the workers (None in this case) → OFC1 failover handler pulls the NIB event log → Curr 
state of NIB event log is [sw0 -> fail] and curr state of local event log is empty [], therefore, OFC1 failover handler 
adds the sw0 failure event to skip list. As a result, OFC1 OF event handler would skip if it receives such a event →  
OFC1 failover handler empties the OF handler’s queue and adds the to-be-processed events to it (empty list) → OFC1 
NIB event handler receives the TOPO_MOD and suspends the switch internally

+ Problem: RCS does not schedule an IR as the switch is suspended in NIB while it is actually working fine. It is 
because the switch recovery event is neither reflected in NIB event log nor in local event log by the time OFC1 is 
performing event reconciliation. Finally, when OFC1 failover handler empties OF event handler’s queue, the recovery 
event is lost. 
+ Solution: OFC1 failover handler should empty the queue. It should only append the reconciled events to the 
beginning of the queue. 
====================================================================================================================
====================================================================================================================
Bug#14 (event processed by two OFCs): Failover module receives the failover request and sends FAILOVER_INIT to OFC1 
→ OFC1 failover handler receives the notification, subscribes to the topology, and pulls the topology state from NIB 
→ OFC1 failover handler schedules ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch 
→ sw0 CPU fails before updating the roles → sw0 CPU recovers → OFC0 OF event handler processes the failure event and 
suspends the switch → OFC1 NIB event handler receives the TOPO_MOD notif and suspends the switch in local directory 
→ OFC1 failover handler subscribes to NIB IRQueue, fetches the IRs from the NIB’s IRQueue and changes its failover 
state to FAILOVER_READY (sw0 is suspended so jump from it) → OFC0 OF event handler adds the failure event to the local 
event log and NIB event log → OFC0 OF event handler processes the switch recovery event and changes the status of sw 
to SW_RUN → OFC1 NIB event handler receives the TOPO_MOD event and changes internal topology → OFC1 OF event handler 
adds the recovery event to the local event log and NIB event log → failover module receives FAILOVER_READY from OFC1 
and sends FAILOVER_TERMINATE to OFC0 → OFC0 failover handler sends termination signal to the workers → OFC0 workers 
terminate → OFC0 failover handler sends termination signal to the monitoring server → OFC0 monitoring server terminates 
→ OFC0 failover handler sends termination signal to the OF event handler → OFC0 OF event handler terminates → OFC0 
failover handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates → failover module changes 
the role of OFC0 to slave and OFC1 to master → OFC1 failover handler receives the notification of becoming the master 
and passes the fetched IRs to the workers (None in this case) →  OFC1 failover handler pulls the NIB event log and local 
event log → OFC1 OF event handler adds the failure event to the local event log → Curr state of NIB event log is 
[sw0 -> fail, sw0 -> recovers] and curr state of local event log is empty [], therefore, OFC1 failover handler adds the 
sw0’s failure and recovery event to the skip list. As a result, the OFC1 OF event handler would skip if it receives such 
an event. → OFC1 failover handler changes the flag of OF event handler to INIT_PROCESS so it can start processing the 
events → OFC1 failover handler processes the recovery event. 

+ Problem: Minor problem in how OFC OF event handler manages the list of skipped events. if the head of skippedList is 
the same as the head of the queue, the OF event handler skips the event. Otherwise, it processes it. In this case, the 
event at the head of the queue is the same as the second event in the skipped list.
+ Solution: Algorithm on OF event handler side:
1: if (skippedList not empty) {
2:	If (currEvent equivalent to Head (skippedList)){
3:		currEvent ← next event in the event queue
4:	}
5:	Remove the head of the skippedList
6:	Goto line 1.
7: }
====================================================================================================================
====================================================================================================================
Bug#15: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler receives 
the notification, subscribes to the topology, and pulls the topology state from NIB → OFC1 failover handler schedules 
ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch → sw0 updates the role and responds 
with ROLE_REPLY → sw0 CPU fails and recovers → OFC1 monitoring server receives the ROLE_REPLY → OFC0 OF event handler 
processes the failure event and suspends the switch → OFC0 OF event handler adds the event to NIB event log → OFC1 
failover handler changes its status to FAILOVER_READY → failover module receives FAILOVER_READY from OFC1 and sends 
FAILOVER_TERMINATE to OFC0 → OFC0 failover handler sends termination signal to the workers → OFC0 workers terminate 
→ OFC0 failover handler sends termination signal to the monitoring server → OFC0 monitoring server terminates → OFC0 
failover handler sends termination signal to the OF event handler → OFC0 OF event handler terminates → OFC0 failover 
handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates → failover module changes the role 
of OFC0 to slave and OFC1 to master →  OFC1 failover handler receives the notification of becoming the master and passes 
the fetched IRs to the workers (None in this case) → OFC1 failover handler pulls the NIB event log and local event log → 
Curr state of NIB event log is [sw0 -> fail] and curr state of local event log is empty [], therefore, OFC1 failover handler 
adds the sw0’s failure event to the skip list. As a result, the OFC1 OF event handler would skip if it receives such an 
event. → OFC1 failover handler changes the flag of OF event handler to INIT_PROCESS so it can start processing the events 
→ OFC1 failover handler schedules ROLE_REQ msg (to ROLE_MASTER) → OFC1 worker forwards the role req → sw0 updates the role 
and replies with ROLE_REPLY → OFC1 monitoring server receives the ROLE_REPLY → OFC1 OF event handler skips the switch 
failure event → OFC1 OF event handler processes the recovery event. However, the current locally maintained state of sw0 
is SW_RUN, and this is a switch recovery event. Therefore, OFC1 does not change anything either in NIB or locally 

+ Problem: RC Seq does not schedule any IR as it thinks the switch is in the failure mode while the switch is working 
fine.
+ Solution: OpenFlow OF event handler while skipping the events should change the topology internal state as well. 
Also, the OFC1 NIB event handler should discard any prior events received due to TOPO_MOD. 
====================================================================================================================
====================================================================================================================
Bug#16: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
receives the notification, subscribes to the topology, and pulls the topology state from NIB → OFC1 failover handler 
schedules ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch → sw0 updates the role 
and responds with ROLE_REPLY → sw0 CPU fails → sw0 CPU recovers → OFC1 OF event handler adds the switch failure event 
to local event log → OFC1 monitoring server receives the ROLE_REPLY → OFC1 failover handler changes its failover 
status to FAILOVER_READY (sw0 is suspended) → failover module receives FAILOVER_READY from OFC1 and sends 
FAILOVER_TERMINATE to OFC0 → OFC0 failover handler sends termination signal to the workers → OFC0 workers terminate 
→ OFC0 failover handler sends termination signal to the monitoring server → OFC0 monitoring server terminates → OFC0 
failover handler sends termination signal to the OF event handler → OFC0 OF event handler terminates → OFC0 failover 
handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates → failover module changes the role 
of OFC0 to slave and OFC1 to master →  OFC1 failover handler receives the notification of becoming the master and 
passes the fetched IRs to the workers (None in this case) → OFC1 failover handler pulls the NIB event log and local 
event log, and prohibits OFC1 OF event handler from processing any other events → OFC1 OF event handler adds the 
recovery event to local event log → Curr state of NIB event log is [] and curr state of local event log is [sw0 -> fail], 
therefore, OFC1 failover handler adds the sw0’s failure event to the OF handler’s event queue. As a result, the OFC1 OF 
event handler would completely process this event. → OFC1 failover handler changes the flag of OF event handler to 
INIT_PROCESS so it can start processing the events → OFC1 failover handler schedules ROLE_REQ msg (to ROLE_MASTER) 
→ OFC1 OF event handler processes the switch failure event and suspends the switch (both locally and in NIB)

+ Problem: Switch recovery event is lost and not processed because after the failover handler pulls the NIB event 
log and local event, OF event handler removes the recovery event from its event queue and adds it to the event log. 
As a result, the recovery event is not considered during reconciliation, and it is not in the event queue.  
+ Solution: Failover handler should first make sure the OF event handler is not in the middle of processing an 
event (by awaiting the OF event handler to be in its init line and setting the state of the OF event handler to 
INIT_NONE). Then, the failover handler should pull the NIB log and local event log. 
====================================================================================================================
====================================================================================================================
Bug#17: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
receives the notification, subscribes to the topology, and pulls the topology state from NIB → OFC1 failover handler 
schedules ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch → sw0 updates the role 
and responds with ROLE_REPLY → sw0 CPU fails → OFC0 OF event handler processes the failure event and suspends the 
switch both locally and in NIB → OFC1 monitoring server receives the ROLE_REPLY →  OFC1 failover handler subscribes 
the NIB IRQueue, fetches the IRs and changes its failover status to FAILOVER_READY → Failover module  receives the 
notification and sends FAILOVER_TERMINATE to OFC0 → OFC0 OF event handler adds the failure event to local and NIB 
event logs → OFC0 failover handler receives the FAILOVER_TERMINATE notification and sends termination signal to 
workers → OFC0 OF event handler adds the failure event to the local event log → OFC0 workers terminate → OFC0 
failover handler sends termination signal to the monitoring server → OFC0 monitoring server terminates → OFC0 
failover handler sends termination signal to the OF event handler → OFC0 OF event handler terminates → OFC0 failover 
handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates →  failover module changes the 
role of OFC0 to slave and OFC1 to master → OFC1 failover handler receives the notification of becoming the master 
and passes the fetched IRs to the workers (None in this case) → OFC1 NIB event handler discards the TOPO_MOD event 
as OFC1 is the master now → OFC1 failover handler pulls the NIB event log and local event log → Curr state of NIB 
event log is [sw0 → Fail] and curr state of local event log is [sw0 → fail], therefore, no need for reconciliation 
→  OFC1 failover handler changes the flag of OF event handler to INIT_PROCESS so it can start processing the events 
→ OFC1 failover handler schedule ROLE_REQ (to ROLE_MASTER) → sw0 updates the role and responds with ROLE_REPLY → 
OFC1 OF event handler starts processing the recovery event. However, as its internal sw state is SW_RUN, it discards 
the event. 

+ Problem: RC Seq does not schedule the IR as it thinks the sw is failed while it is working fine.
+ Solution: OFC1 NIB should not subscribe to the topology, and it should not try to extract the topology from NIB. 
Instead, OFC1 should always rely on the ground truth which is inside the dataplane. 
====================================================================================================================
====================================================================================================================
EVENT SYNC -- Alg#4: 
-- (Slave Part) Slave OFC OpenFlow processes the events, and adds them to the local event log. After the OFC role is 
completely transferred to the OFC, its failover handler stops the OF event handler, reconciles the internal event log 
with NIB’s event log, adds the necessary events to OF event handler’s queue, and wakes up the OF event handler. 
-- (Master Part) Master OFC adds the events to the NIB event log after completely processing an IR. Only the master 
OFC has write access to NIB event log.

RECONCIL NIB & LOCAL EVENT LOG -- Alg#2: Sequentially go through the event logs and find the events in local event 
logs that are not inside the NIB log file. For every switch, two cases might happen, either NIB event log is a head 
of local event log or vice versa. If the former happens, the OF event handler should discard some of the events that 
it is going to receive. In the latter case, the OF event handler should process those events and update the NIB.
 
Bug#18: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler receives 
the notification, subscribes to the topology, and pulls the topology state from NIB → OFC1 failover handler schedules 
ROLE_REQ msg (to ROLE_EQUAL) → OFC1 worker forwards the role req msg to the switch → sw0 updates the role and responds 
with ROLE_REPLY → sw0 CPU fails → OFC0 OF event handler processes the failure event and suspends the switch both locally 
and in NIB → OFC1 monitoring server receives the ROLE_REPLY →  OFC1 failover handler subscribes the NIB IRQueue, fetches 
the IRs and changes its failover status to FAILOVER_READY → Failover module  receives the notification and sends 
FAILOVER_TERMINATE to OFC0 → OFC0 OF event handler adds the failure event to local and NIB event logs → OFC0 failover 
handler receives the FAILOVER_TERMINATE notification and sends termination signal to workers → OFC0 OF event handler 
adds the failure event to the local event log → OFC0 workers terminate → OFC0 failover handler sends termination signal 
to the monitoring server → OFC0 monitoring server terminates → OFC0 failover handler sends termination signal to the OF 
event handler → OFC0 OF event handler terminates → OFC0 failover handler changes its failover status to 
FAILOVER_TERMINATE_DONE and self terminates →  failover module changes the role of OFC0 to slave and OFC1 to master → 
OFC1 OF event handler processes the failure event and applies it to NIB

+ Problem: failure event is applied to NIB twice.
+ Solution: Three flags for OF event handler;
INIT_NONE: does not start processing any event
INIT_PROCESS: process the events but does not apply changes to NIB.
INIT_MASTER: process the events and apply them to NIB. 
====================================================================================================================
====================================================================================================================
Bug#19: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 →Sequencer schedules an IR → 
OFC0 NIB event handler receives the IR and passes the IR to workers → OFC1 failover handler schedules ROLE_REQ 
(to ROLE_EQUAL) → OFC0 worker forwards the IR → sw0 installs the IR and sends back the confirmation → sw0 CPU fails 
→ sw0 CPU recovers → OFC0 monitoring server receives the confirmation and changes the flag of IR to IR_DONE → OFC0 
OF event handler processes the switch failure event and suspends the switch (both locally and in NIB) → OFC0 OF event 
handler adds the event to NIB event log and local event log → OFC0 OF event handler processes the switch recovery 
event and changes the status of sw to SW_RUN → OFC1 OF event handler processes the switch failure event and suspends 
the switch locally → OFC0 OF event handler adds the switch recovery event to NIB event log and local event log → OFC1 
OF event handler adds the switch failure to local event log → OFC1 worker does not sends the ROLE_REQ msg as the sw 
is suspended → OFC1 OF event handler processes the switch recovery event and changes the state of switch to SW_RUN 
locally → OFC1 failover handler waits for the ROLE_REPLY as it does not know the switch is failed

+ Problem: deadlock in failover. setRecoveredSw which was used to notify the failover handler about switch failure 
and recovery was previously filled by the NIB event handler. Now, as the NIB event handler no longer subscribes to 
the topology in NIB, no one fills it. 
+ Solution: OFC OF event handler should fill the setRecoveredSw.
====================================================================================================================
====================================================================================================================
Bug#20: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
schedules ROLE_REQ (to ROLE_EQUAL) → OFC1 worker forwards the ROLE_REQ msg → switch CPU fails before updating the 
role → OFC0 OF event handler processes the event and suspends the switch both internally and in NIB → OFC0 OF event 
handler adds the event to NIB event log and local event log → OFC1 OF event handler processes the failure event and 
suspends the switch internally → OFC1 OF event handler adds the event to local event log →  OFC1 failover handler 
subscribes the NIB IRQueue, fetches the IRs and changes its failover status to FAILOVER_READY → OFC1 OF event handler 
processes the switch recovery event and changes the status of sw to SW_RUN internally → Failover module receives the 
notification and sends FAILOVER_TERMINATE to OFC0 → OFC1 OF event handler adds the switch recovery event to local 
event log → OFC0 failover handler receives the FAILOVER_TERMINATE notification and sends termination signal to workers 
→ OFC0 workers terminate → OFC0 failover handler sends termination signal to the monitoring server → OFC0 monitoring 
server terminates → OFC0 failover handler sends termination signal to the OF event handler → OFC0 OF event handler 
terminates → OFC0 failover handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates →  
failover module changes the role of OFC0 to slave and OFC1 to master → OFC1 failover handler receives the notification 
of becoming the master and passes the fetched IRs to the workers (None in this case) → OFC1 failover handler pulls the 
NIB event log and local event log → Curr state of NIB event log is [sw0 → Fail] and curr state of local event log is 
[sw0 → fail, sw0 → recovery], therefore, OFC1 failover handler adds the recovery events to OF event handler’s event 
queue. So, it is going to be processed again and applied to NIB →  OFC1 failover handler changes the flag of OF event 
handler to INIT_MASTER so it can start processing the events → OFC1 failover handler does not apply the recovery event 
to NIB because based on its internal status the current state of NIB is SW_RUN, therefore, it does not need to be changed.
 
+ Problem:  RCS sequencer does not schedule any IR as the status of switch in NIB is SW_SUSPEND while the switch is 
working fine.
+ Solution: During the event log reconciliation, if the local event log is ahead of NIB event log for a switch, 
pull the switch state from NIB into the local state. 
====================================================================================================================
====================================================================================================================
Bug#21: Sequencer schedules an IR → Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → 
OFC0 NIB event handler receives the IR and passes the IR to workers → OFC1 failover handler schedules ROLE_REQ 
(to ROLE_EQUAL) → OFC0 worker forwards the IR → sw0 installs the IR but its CPU fails before sending the confirmation 
(confirmation is lost) → sw0 CPU recovers → OFC1 worker forwards the ROLE_REQ → sw0 updates the role and replies with 
ROLE_REPLY → OFC0 OF event handler processes the failure event and suspends the switch → OFC0 OF event handler adds 
the failure event to NIB and local event log → OFC0 OF event handler processes the recover event and changes flag of 
switch to SW_RUN → OFC0 OF event handler changes flag of IR from IR_SENT to IR_NONE (as it thinks the IR is not 
installed to the switch) → OFC0 OF event handler adds the recovery event to both NIB and local event log → OFC1 
monitoring server receives the ROLE_REPLY → OFC1 failover handler subscribes the NIB IRQueue, fetches the IRs and 
changes its failover status to FAILOVER_READY → Failover module receives the notification and sends FAILOVER_TERMINATE 
to OFC0 → OFC0 failover handler receives the FAILOVER_TERMINATE notification and sends termination signal to workers 
→ OFC0 workers terminate → OFC0 failover handler sends termination signal to the monitoring server → OFC0 monitoring 
server terminates → OFC0 failover handler sends termination signal to the OF event handler → OFC0 OF event handler 
terminates → OFC0 failover handler changes its failover status to FAILOVER_TERMINATE_DONE and self terminates →  
failover module changes the role of OFC0 to slave and OFC1 to master → OFC1 failover handler receives the notification 
of becoming the master and passes the fetched IRs to the workers (IR1 INSTALL_FLOW to sw0) → OFC1 worker forwards the 
IR → sw0 installs the IR again

+ Problem: IR is installed by two OFCs.
+ Solution: Instead of resetting the flag of all IRs (with IR_SENT flag) corresponding to the recovered switch to 
IR_NONE, the OFC OF event handler should send FLOW_STAT_REQ and pull all the IRs from TCAM of the switch. It should 
then reconcile the state of NIB.
====================================================================================================================
====================================================================================================================
Bug #22: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
receives the notification and schedules ROLE_REQ msg → OFC worker forwards the ROLE_REQ msg → sw0 CPU fails and the 
msg is lost → sw0 CPU recovers → OFC1 OF event handler process the switch failure event and suspends the switch → 
OFC1 OF event handler adds the failure event to local event log → OFC1 failover handler subscribes to the NIB’s 
IRQueue, pulls the NIB’s IR Queue and changes its failover status to FAILOVER_READY (it neglects sw0 since sw0’s 
local status is SW_SUSPEND)→ OFC0 OF event handler processes the failure event and suspends the switch both locally 
and in NIB → OFC0 OF event handler adds the failure event to the NIB’s event log and local event log → OFC0 OF event 
handler processes the switch recovery event and changes the state of switch to SW_RUN (both locally and in NIB) → 
Failover module receives the FAILOVER_READY from OFC1 and sends FAILOVER_TERMINATE to OFC0 → OFC0 failover handler 
receives the FAILOVER_TERMINATE and sends termination signal to OFC0 workers → Since the switch recovery event is 
the last event for sw0, OFC0 OF event handler changes the flag of sw0 to SW_RECONCILE and schedules a FLOW_STAT_REQ 
→ OFC0 OF event handler adds the switch recovery event to NIB’s and local event log → OFC0 workers gracefully 
terminate → After the workers terminated, OFC0 sends termination signal to the monitoring server → OFC0 monitoring 
server terminates → After the monitoring server termination, OFC0 sends termination signal to the OF event handler 
→ OFC0 OF event handler terminates → OFC0 failover handler changes its failover status to FAILOVER_TERMINATE_DONE 
and self terminates → Failover module changes the roles of OFCs (OFC0 |-> slave, OFC1 |-> master)  → OFC1 failover 
handler receives the notification of becoming the master and passes the fetched IRs to the workers (None in this case) 
→ OFC1 failover handler changes the flag of OF event handler to INIT_NONE → OFC1 failover handler pulls the event log 
from NIB and makes a copy from local event log →  Curr state of NIB event log is [sw0 → fail, sw0 → recovery] and curr 
state of local event log is [sw0 → fail], therefore, OFC1 failover handler adds the recovery events to the skipped list 
→  OFC1 failover handler changes the flag of OF event handler to INIT_MASTER so it can start processing the events →
 OFC1 OF event handler skips the recovery event and only changes the internal state of sw to SW_RUN

+ Problem: sw0’s state in NIB remains SW_RECONCILE forever. As a result, the RCS sequencer does not schedule any IR 
for the switch. 
+ Solution: OFC1 OF event handler should send FLOW_STAT_REQ during event reconciliation when 
(1) switch status is SW_SUSPEND locally. 
(2) switch status is SW_RECONCILE in NIB. 
(3) it is skipping some recovery event for that switch. 
(4) the recovery event is the last event for the switch in the queue. 
====================================================================================================================
====================================================================================================================
Bug#23: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
receives the notification and schedules ROLE_REQ msg → OFC worker forwards the ROLE_REQ msg → sw0 CPU fails and 
the msg is lost → OFC1 OF event handler process the switch failure event and suspends the switch locally → OFC1 OF 
event handler adds the failure event to local event log → OFC0 OF event handler processes the failure event and 
suspends the switch both locally and in NIB →  OFC0 OF event handler adds the failure event to the NIB’s event log 
and local event log → OFC1 failover handler subscribes to the NIB’s IRQueue, pulls the NIB’s IR Queue and changes 
its failover status to FAILOVER_READY (it neglects sw0 since sw0’s local status is SW_SUSPEND) → sw0 CPU recovers 
→ OFC1 OF event handler processes the switch recovery event and changes the state of sw0 to SW_RUN locally → OFC0 
OF event handler processes the switch recovery event and changes the state of sw0 to SW_RUN (both locally and in NIB) 
→ Failover module receives the FAILOVER_READY from OFC1 and sends FAILOVER_TERMINATE to OFC0 → Since the switch 
recovery event is the last event for sw0, OFC0 OF event handler changes the flag of sw0 to SW_RECONCILE and 
schedules a FLOW_STAT_REQ → OFC0 OF event handler adds the switch recovery event to local event log and NIB’s 
event log → OFC0 failover handler receives the FAILOVER_TERMINATE and sends termination signal to OFC0 workers 
→ OFC1 OF event handler adds the switch recovery event to local event log → OFC0 workers gracefully terminate → 
After the workers terminated, OFC0 sends termination signal to the monitoring server → OFC0 monitoring server 
terminates → After the monitoring server termination, OFC0 sends termination signal to the OF event handler → 
OFC0 OF event handler terminates → OFC0 failover handler changes its failover status to FAILOVER_TERMINATE_DONE 
and self terminates → Failover module changes the roles of OFCs (OFC0 |-> slave, OFC1 |-> master)  → OFC1 failover 
handler receives the notification of becoming the master and passes the fetched IRs to the workers (None in this case) 
→  OFC1 failover handler changes the flag of OF event handler to INIT_NONE → OFC1 failover handler pulls the event 
log from NIB and makes a copy from local event log → Curr state of NIB event log is [sw0 → fail, sw0 → recovery] 
and curr state of local event log is [sw0 → fail, sw1 → recovery], therefore, OFC1 failover handler does not do 
anything. 

+ Problem: The state of switch remains SW_RECONCILE at NIB waiting for the state to be reconciled. However, neither 
OFC0 nor OFC1 has sent the FLOW_STAT_REQ. As a result, RC sequencers do not schedule any IR for the switch.
+ Solution: + Solution: During event reconciliation, if the status of the switch in NIB is SW_RECONCILE while both 
OFCs have processed all the events, the OFC1 OF event handler should add the latest recovery event to both 
skippList and head of the event queue.
====================================================================================================================
====================================================================================================================
Bug#24: Failover module receives the failover request and sends FAILOVER_INIT to OFC1 → OFC1 failover handler 
receives the notification and schedules ROLE_REQ msg → OFC worker forwards the ROLE_REQ msg → sw0 CPU fails and the 
msg is lost → OFC1 OF event handler process the switch failure event and suspends the switch locally → OFC1 failover 
handler subscribes to the NIB’s IRQueue, pulls the NIB’s IR Queue and changes its failover status to FAILOVER_READY 
(it neglects sw0 since sw0’s local status is SW_SUSPEND) → sw0 CPU recovers → Failover module receives the 
FAILOVER_READY from OFC1 and sends FAILOVER_TERMINATE to OFC0 → OFC1 OF event handler adds the failure event to 
local event log → OFC0 OF event handler processes the switch failure event and suspends the switch (locally and in 
NIB) → OFC0 failover handler receives the FAILOVER_TERMINATE and sends termination signal to OFC0 workers → OFC0 
workers terminate gracefully → OFC1 OF event handler processes the switch recovery event and changes the state of 
switch to SW_RUN locally → After the workers terminated, OFC0 sends termination signal to the monitoring server → 
OFC0 OF event handler adds the failure event to local and NIB’s event log → OFC1 OF event handler adds the failure 
event to local event log → OFC0 monitoring server terminates gracefully → OFC0 OF event handler processes the switch 
recovery event and changes the state of sw0 to SW_RUN (both locally and in NIB) → Since the switch recovery event 
is the last event for sw0, OFC0 OF event handler changes the flag of sw0 to SW_RECONCILE and schedules a FLOW_STAT_REQ 
→ After the monitoring server termination, OFC0 sends termination signal to the OF event handler → OFC0 OF event handler 
adds the recovery event to both NIB and local event log → OFC0 OF event handler terminates → OFC0 failover handler 
changes its failover status to FAILOVER_TERMINATE_DONE and self terminates → Failover module changes the roles of 
OFCs (OFC0 |-> slave, OFC1 |-> master)  → OFC1 failover handler receives the notification of becoming the master and 
passes the fetched IRs to the workers (None in this case) →  OFC1 failover handler changes the flag of OF event handler 
to INIT_NONE → OFC1 failover handler pulls the event log from NIB and makes a copy from local event log → Curr state of 
NIB event log is [sw0 → fail, sw0 → recovery] and curr state of local event log is [sw0 → fail, sw1 → recovery]. 
However, as the state of switch in NIB is SW_RECONCILE, OFC1 failover handler adds the recovery event to both 
skipplist and the head of event queue → OFC1 OF event handler skips the recovery event and does not schedule the 
FLOW_STAT_REQ

+ Problem: The switch has SW_RECONCILE state and RCS sequencer does not schedule any IR for that. The previous 
state of switch before skipping the recovery event by OFC1 is SW_RUN. Therefore, the OFC1 OF event handler skips 
the event by default without doing anything.
+ Solution: OFC1 failover handler should change the state of switch to SW_SUSPEND during event reconciliation. 
====================================================================================================================
====================================================================================================================
Bug#25: Sequencer schedules an IR {IR1} → Failover module receives the failover request and sends FAILOVER_INIT to 
OFC1 → OFC1 failover handler receives the notification and schedules ROLE_REQ msg → OFC worker forwards the ROLE_REQ 
msg → sw0 updates the role (OFC1 |-> ROLE_EQUAL) and responds with ROLE_REPLY → sw0 CPU fails → sw0 CPU recovers → 
OFC0 OF event handler processes the failure event and suspends the switch (both locally and in NIB) → OFC0 OF event 
handler adds the failure event to NIB’s and local event log → OFC0 OF event handler process the recovery event and 
changes the state of sw0 to SW_RUN → Since the switch recovery event is the last event for sw0, OFC0 OF event handler 
changes the flag of sw0 to SW_RECONCILE and schedules a FLOW_STAT_REQ → OFC0 NIB event handler receives the 
notification for IR and adds the IR to the workers’ queue → OFC0 worker forwards the FLOW_STAT_REQ → sw0 replies with 
FLOW_STAT_REPLY (TCAM empty) → OFC0 OF event handler adds the recovery event to NIB’s and local event log → OFC0 
worker forwards the IR → sw0 installs the IR and responds with a confirmation → OFC1 monitoring server receives the 
ROLE_REPLY → OFC1 failover handler subscribes to the NIB’s IRQueue, pulls the NIB’s IR Queue [IR1] and changes its 
failover status to FAILOVER_READY → OFC0 monitoring server receives the FLOW_STAT_REPLY and changes flag of sw0 to 
SW_RUN (both locally and in NIB). Since the body of FLOW_STAT_REPLY is empty, OFC0 monitoring server changes the flag 
of IR from IR_SENT to IR_NONE → Failover module gets the notification of FAILOVER_READY from OFC1 and sends 
FAILOVER_TERMINATE to OFC0 → OFC0 failover handler receives FAILOVER_TERMINATE and sends termination signal to the 
workers → OFC0 workers gracefully terminate → After the workers terminated, OFC0 sends termination signal to the 
monitoring server → OFC0 monitoring server terminates → After the monitoring server termination, OFC0 sends 
termination signal to the OF event handler → OFC0 OF event handler terminates → OFC0 failover handler changes 
its failover status to FAILOVER_TERMINATE_DONE and self terminates → Failover module changes the roles of OFCs 
(OFC0 |-> slave, OFC1 |-> master)  → OFC1 failover handler receives the notification of becoming the master 
and passes the fetched IRs {IR1} to the workers → OFC1 worker forwards the IR {IR1}

+ Problem: IR is installed by two OFCs as a result of a combination of failover + switch transient failure + 
reconciliation algorithm. This happens because OFC0 monitoring server is terminated before receiving the 
confirmation of the installed IR. As a result of reconciliation, the IR has IR_NONE status instead of IR_SENT. 
Therefore, the monitoring server assumes the IR is lost due to the failure.
+ Solution: OFC worker should not forward an IR corresponding to a switch with SW_RECONCILE status. 
