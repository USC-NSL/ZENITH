<<
[
 _TEAction |-> [
   position |-> 1,
   name |-> "Initial predicate",
   location |-> "Unknown location"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 0),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> 0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 2,
   name |-> "ControllerSeqProc",
   location |-> "line 4959, col 28 to line 5026, col 69 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 0),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> 0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "SchedulerMechanism" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {1}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 3,
   name |-> "SchedulerMechanism",
   location |-> "line 5028, col 29 to line 5113, col 70 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> STATUS_START_SCHEDULING, next |-> 1]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> 0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ScheduleTheIR" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {1}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 4,
   name |-> "ScheduleTheIR",
   location |-> "line 5115, col 24 to line 5178, col 65 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<rc0, CONT_SEQ>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> STATUS_START_SCHEDULING, next |-> 1]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> 0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "sendIRQueueModNotification" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {ofc0}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {1}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 5,
   name |-> "sendIRQueueModNotification",
   location |-> "line 5180, col 37 to line 5274, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<rc0, CONT_SEQ>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> STATUS_START_SCHEDULING, next |-> 1]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "sendIRQueueModNotification" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {1}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 6,
   name |-> "sendIRQueueModNotification",
   location |-> "line 5180, col 37 to line 5274, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<rc0, CONT_SEQ>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "sequencerApplyFailure" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 7,
   name |-> "sequencerApplyFailure",
   location |-> "line 5276, col 32 to line 5353, col 73 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_NONE),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "OfcFailoverNewMasterInitialization"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 8,
   name |-> "OfcFailoverNewMasterInitialization",
   location |-> "line 8149, col 45 to line 8256, col 86 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> 0] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 9,
   name |-> "NibEventHandlerProc",
   location |-> "line 5476, col 30 to line 5549, col 71 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> FALSE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> NO_TAG, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> -1]>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 10,
   name |-> "ofcFailoverHandlerProc",
   location |-> "line 5553, col 33 to line 5657, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ScheduleRoleUpdateEqual" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {s0}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> NO_TAG, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> -1]>> @@ ofc1 :> <<>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 11,
   name |-> "ScheduleRoleUpdateEqual",
   location |-> "line 5659, col 34 to line 5759, col 75 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<ofc1, FAILOVER_HANDLER>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<ofc1, FAILOVER_HANDLER>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "ScheduleRoleUpdateEqual" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> NO_TAG, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> -1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 12,
   name |-> "ScheduleRoleUpdateEqual",
   location |-> "line 5659, col 34 to line 5759, col 75 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 0,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> 0] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> NO_TAG, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> -1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 13,
   name |-> "ControllerThread",
   location |-> "line 6562, col 27 to line 6697, col 68 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_LOCKING, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadForwardIR" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 14,
   name |-> "ControllerThreadForwardIR",
   location |-> "line 6966, col 36 to line 7080, col 77 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> 0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NIC_ASIC_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 15,
   name |-> "SwitchRcvPacket",
   location |-> "line 3108, col 26 to line 3173, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchNicAsicInsertToOfaBuff" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<NIC_ASIC_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 16,
   name |-> "SwitchNicAsicInsertToOfaBuff",
   location |-> "line 3175, col 39 to line 3272, col 80 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> 0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 17,
   name |-> "SwitchOfaProcIn",
   location |-> "line 3447, col 26 to line 3518, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcessPacket" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 18,
   name |-> "SwitchOfaProcessPacket",
   location |-> "line 3520, col 33 to line 3644, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<[IR |-> 1, from |-> ofc0]>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [type |-> 0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<INSTALLER, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 19,
   name |-> "SwitchInstallerProc",
   location |-> "line 3907, col 30 to line 3979, col 71 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{}>>,
 installedIRs |-> <<>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerInsert2TCAM" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<INSTALLER, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 20,
   name |-> "SwitchInstallerInsert2TCAM",
   location |-> "line 3981, col 37 to line 4075, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerSendConfirmation" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<INSTALLER, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 21,
   name |-> "SwitchInstallerSendConfirmation",
   location |-> "line 4077, col 42 to line 4184, col 83 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<[IR |-> 1, from |-> ofc0]>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 0,
 controlMsgCounter |-> (s0 :> 0),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 0),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<{s0}>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {}),
 switchLock |-> <<OFA_OUT, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 22,
   name |-> "SwitchFailure",
   location |-> "line 4190, col 24 to line 4360, col 65 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 1,
 controlMsgCounter |-> (s0 :> 1),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {ofc0, ofc1}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ""),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "swFailureSendStatusMsg" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1}),
 switchLock |-> <<SW_FAILURE_PROC, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> Failed,
        nicAsic |-> NotFailed,
        ofa |-> Failed,
        installer |-> Failed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 23,
   name |-> "swFailureSendStatusMsg",
   location |-> "line 4362, col 33 to line 4446, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 1,
 controlMsgCounter |-> (s0 :> 1),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {ofc1}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc0),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "swFailureSendStatusMsg" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>> @@ ofc1 :> <<>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1}),
 switchLock |-> <<SW_FAILURE_PROC, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> Failed,
        nicAsic |-> NotFailed,
        ofa |-> Failed,
        installer |-> Failed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 24,
   name |-> "swFailureSendStatusMsg",
   location |-> "line 4362, col 33 to line 4446, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 1,
 controlMsgCounter |-> (s0 :> 1),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "swFailureSendStatusMsg" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1}),
 switchLock |-> <<SW_FAILURE_PROC, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> Failed,
        nicAsic |-> NotFailed,
        ofa |-> Failed,
        installer |-> Failed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 25,
   name |-> "swFailureSendStatusMsg",
   location |-> "line 4362, col 33 to line 4446, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 1,
 controlMsgCounter |-> (s0 :> 1),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1}),
 switchLock |-> <<OFA_OUT, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> Failed,
        nicAsic |-> NotFailed,
        ofa |-> Failed,
        installer |-> Failed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 26,
   name |-> "ghostProc",
   location |-> "line 4884, col 20 to line 4955, col 76 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 1,
 controlMsgCounter |-> (s0 :> 1),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> Failed,
        nicAsic |-> NotFailed,
        ofa |-> Failed,
        installer |-> Failed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 27,
   name |-> "SwitchResolveFailure",
   location |-> "line 4450, col 31 to line 4631, col 72 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {ofc0, ofc1}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ""),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "swRecoverySendStatusMsg" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<SW_RESOLVE_PROC, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 28,
   name |-> "swRecoverySendStatusMsg",
   location |-> "line 4633, col 34 to line 4721, col 75 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {ofc1}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc0),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "swRecoverySendStatusMsg" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<SW_RESOLVE_PROC, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 29,
   name |-> "swRecoverySendStatusMsg",
   location |-> "line 4633, col 34 to line 4721, col 75 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "swRecoverySendStatusMsg" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<SW_RESOLVE_PROC, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 30,
   name |-> "swRecoverySendStatusMsg",
   location |-> "line 4633, col 34 to line 4721, col 75 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 1,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> 0]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_NONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 31,
   name |-> "ControllerThread",
   location |-> "line 6562, col 27 to line 6697, col 68 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_LOCKING, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadForwardIR" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 32,
   name |-> "ControllerThreadForwardIR",
   location |-> "line 6966, col 36 to line 7080, col 77 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<[type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NIC_ASIC_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 33,
   name |-> "SwitchRcvPacket",
   location |-> "line 3108, col 26 to line 3173, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchNicAsicInsertToOfaBuff" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NIC_ASIC_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 34,
   name |-> "SwitchNicAsicInsertToOfaBuff",
   location |-> "line 3175, col 39 to line 3272, col 80 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<[type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc0]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 35,
   name |-> "SwitchOfaProcIn",
   location |-> "line 3447, col 26 to line 3518, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcessPacket" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 36,
   name |-> "SwitchOfaProcessPacket",
   location |-> "line 3520, col 33 to line 3644, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchSendRoleReply" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 37,
   name |-> "SwitchSendRoleReply",
   location |-> "line 3646, col 30 to line 3723, col 71 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> 0]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NIC_ASIC_OUT, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 38,
   name |-> "SwitchFromOFAPacket",
   location |-> "line 3277, col 30 to line 3350, col 71 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchNicAsicSendOutMsg" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NIC_ASIC_OUT, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 39,
   name |-> "SwitchNicAsicSendOutMsg",
   location |-> "line 3352, col 34 to line 3442, col 75 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 2, next |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL], id |-> 2]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 40,
   name |-> "ControllerThreadReleaseSemaphoreAndScheduledSet",
   location |-> "line 6699, col 58 to line 6866, col 99 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [type |-> 0] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 41,
   name |-> "ControllerEventHandlerProc",
   location |-> "line 7233, col 37 to line 7473, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_SUSPEND),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_SUSPEND) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEvenHanlderRemoveEventFromQueue" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 42,
   name |-> "ControllerEvenHanlderRemoveEventFromQueue",
   location |-> "line 7475, col 52 to line 7615, col 93 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_SUSPEND),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_SUSPEND) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 43,
   name |-> "ControllerEventHandlerProc",
   location |-> "line 7233, col 37 to line 7473, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [sw |-> s0, type |-> START_RESET_IR] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "getIRsToBeChecked" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 44,
   name |-> "getIRsToBeChecked",
   location |-> "line 7617, col 28 to line 7696, col 69 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [sw |-> s0, type |-> START_RESET_IR] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ResetAllIRs" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {1} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 45,
   name |-> "ResetAllIRs",
   location |-> "line 7698, col 22 to line 7775, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [sw |-> s0, type |-> START_RESET_IR] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEvenHanlderRemoveEventFromQueue" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<[swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 46,
   name |-> "ControllerEvenHanlderRemoveEventFromQueue",
   location |-> "line 7475, col 52 to line 7615, col 93 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_SLAVE)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> 0]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_SENT, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 47,
   name |-> "ControllerMonitorCheckIfMastr",
   location |-> "line 7913, col 40 to line 8061, col 81 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_INIT),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "WaitForSwitchUpdateRoleACK" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 48,
   name |-> "WaitForSwitchUpdateRoleACK",
   location |-> "line 5761, col 37 to line 5869, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {1}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 1, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> -1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0, ofc1}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> <<[tag |-> <<ofc0, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 1]>> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 49,
   name |-> "ControllerThreadReleaseSemaphoreAndScheduledSet",
   location |-> "line 6699, col 58 to line 6866, col 99 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_NONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverCurrMasterTerminate"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0, ofc1}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 50,
   name |-> "ofcFailoverCurrMasterTerminate",
   location |-> "line 8258, col 41 to line 8356, col 82 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "ofcFailoverHandlerProc" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc0, ofc1}, SwSuspensionStatus |-> {ofc0}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 51,
   name |-> "ofcFailoverHandlerProc",
   location |-> "line 5553, col 33 to line 5657, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_INIT @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "ControllerThread" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "WaitForWorkersTermination" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 52,
   name |-> "ControllerThread",
   location |-> "line 6562, col 27 to line 6697, col 68 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "WaitForWorkersTermination" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 53,
   name |-> "WaitForWorkersTermination",
   location |-> "line 6234, col 36 to line 6324, col 77 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_INIT @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "WaitForMonitoringServerTermination" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 54,
   name |-> "ControllerMonitorCheckIfMastr",
   location |-> "line 7913, col 40 to line 8061, col 81 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_NONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "WaitForMonitoringServerTermination" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 55,
   name |-> "WaitForMonitoringServerTermination",
   location |-> "line 6326, col 45 to line 6439, col 86 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_INIT) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "WaitForOFEventHandlerTermination" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 56,
   name |-> "ControllerEventHandlerProc",
   location |-> "line 7233, col 37 to line 7473, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "WaitForOFEventHandlerTermination" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 57,
   name |-> "WaitForOFEventHandlerTermination",
   location |-> "line 6441, col 43 to line 6549, col 84 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_SLAVE @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "ofcFailoverChangeRoles"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 58,
   name |-> "ofcFailoverChangeRoles",
   location |-> "line 8358, col 33 to line 8436, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> << >>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 59,
   name |-> "QueryIRQueueNIB",
   location |-> "line 5871, col 26 to line 5954, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_NONE>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 2),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 2,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> ROLE_REQ, to |-> s0, roletype |-> ROLE_EQUAL]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThread" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> NO_TAG, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> -1]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 60,
   name |-> "ControllerThread",
   location |-> "line 6562, col 27 to line 6697, col 68 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_LOCKING, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadForwardIR" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NO_LOCK, NO_LOCK>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 61,
   name |-> "ControllerThreadForwardIR",
   location |-> "line 6966, col 36 to line 7080, col 77 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NIC_ASIC_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 62,
   name |-> "SwitchRcvPacket",
   location |-> "line 3108, col 26 to line 3173, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchNicAsicInsertToOfaBuff" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<NIC_ASIC_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 63,
   name |-> "SwitchNicAsicInsertToOfaBuff",
   location |-> "line 3175, col 39 to line 3272, col 80 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<[type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> ROLE_REQ, to |-> s0, from |-> ofc1, roletype |-> ROLE_EQUAL]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 64,
   name |-> "SwitchOfaProcIn",
   location |-> "line 3447, col 26 to line 3518, col 67 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcessPacket" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<OFA_IN, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 65,
   name |-> "SwitchOfaProcessPacket",
   location |-> "line 3520, col 33 to line 3644, col 74 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<[IR |-> 1, from |-> ofc1]>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc0]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerProc" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<INSTALLER, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 66,
   name |-> "SwitchInstallerProc",
   location |-> "line 3907, col 30 to line 3979, col 71 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0}>>,
 installedIRs |-> <<1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc1]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerInsert2TCAM" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<INSTALLER, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
],
[
 _TEAction |-> [
   position |-> 67,
   name |-> "SwitchInstallerInsert2TCAM",
   location |-> "line 3981, col 37 to line 4075, col 78 of module PlannedOfcFailoverWithoutReconciliation"
 ],
 ContProcSet |-> {<<ofc0, t0>>, <<ofc0, CONT_MONITOR>>, <<ofc0, CONT_EVENT>>, <<ofc1, t0>>, <<ofc1, CONT_MONITOR>>, <<ofc1, CONT_EVENT>>, <<rc0, CONT_SEQ>>},
 FirstInstall |-> <<0>>,
 IR2SW |-> <<s0>>,
 IRQueueNIB |-> << >>,
 IRStatus |-> <<IR_SENT>>,
 Installer2OfaBuff |-> (s0 :> <<>>),
 MAX_IR_COUNTER |-> 15,
 NIBEventLog |-> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 NIBSwSuspensionStatus |-> (s0 :> SW_RUN),
 NicAsic2OfaBuff |-> (s0 :> <<>>),
 Ofa2InstallerBuff |-> (s0 :> <<>>),
 Ofa2NicAsicBuff |-> (s0 :> <<>>),
 SetScheduledIRs |-> (s0 :> {}),
 SwProcSet |-> {<<SW_RESOLVE_PROC, s0>>, <<NIC_ASIC_IN, s0>>, <<SW_FAILURE_PROC, s0>>, <<INSTALLER, s0>>, <<OFA_IN, s0>>, <<OFA_OUT, s0>>, <<NIC_ASIC_OUT, s0>>},
 TCAM |-> (s0 :> <<1, 1>>),
 auxEventCounter |-> 2,
 controlMsgCounter |-> (s0 :> 2),
 controller2Switch |-> (s0 :> <<>>),
 controllerFailedModules |-> (<<ofc0, WATCH_DOG>> :> {} @@ <<ofc1, WATCH_DOG>> :> {} @@ <<rc0, WATCH_DOG>> :> {}),
 controllerGlobalLock |-> <<NO_LOCK, NO_LOCK>>,
 controllerLocalLock |-> (ofc0 :> <<NO_LOCK, NO_LOCK>> @@ ofc1 :> <<NO_LOCK, NO_LOCK>> @@ rc0 :> <<NO_LOCK, NO_LOCK>>),
 controllerRoleInSW |-> (ofc0 :> (s0 :> ROLE_MASTER) @@ ofc1 :> (s0 :> ROLE_EQUAL)),
 controllerSet |-> (<<ASYNC_NET_EVE_GEN, s0>> :> {}),
 controllerSet_ |-> (<<SW_FAILURE_PROC, s0>> :> {}),
 controllerSet_s |-> (<<SW_RESOLVE_PROC, s0>> :> {}),
 controllerStateNIB |-> (<<ofc0, t0>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc0, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<ofc1, t0>> :> [type |-> STATUS_SENT_DONE, index |-> 3, next |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]] @@ <<ofc1, CONT_MONITOR>> :> [type |-> NO_STATUS] @@ <<ofc1, CONT_EVENT>> :> [type |-> NO_STATUS] @@ <<rc0, CONT_SEQ>> :> [type |-> NO_STATUS]),
 controllerSubmoduleFailNum |-> (ofc0 :> 0 @@ ofc1 :> 0 @@ rc0 :> 0),
 controllerSubmoduleFailStat |-> (<<ofc0, t0>> :> NotFailed @@ <<ofc0, CONT_MONITOR>> :> NotFailed @@ <<ofc0, CONT_EVENT>> :> NotFailed @@ <<ofc1, t0>> :> NotFailed @@ <<ofc1, CONT_MONITOR>> :> NotFailed @@ <<ofc1, CONT_EVENT>> :> NotFailed @@ <<rc0, CONT_SEQ>> :> NotFailed),
 currSW |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> s0),
 dependencyGraph |-> {},
 egressMsg |-> (<<NIC_ASIC_OUT, s0>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 entry |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 entryIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 3),
 event |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> 0] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> 0]),
 eventID |-> (<<ASYNC_NET_EVE_GEN, s0>> :> 0),
 eventMsg |-> (<<ASYNC_NET_EVE_GEN, s0>> :> [type |-> 0]),
 eventSkipList |-> (ofc0 :> (s0 :> <<>>) @@ ofc1 :> (s0 :> <<>>)),
 event_ |-> (<<ofc0, NIB_EVENT_HANDLER>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, NIB_EVENT_HANDLER>> :> [type |-> 0]),
 failedElem |-> (<<SW_FAILURE_PROC, s0>> :> "cpu"),
 failedSet |-> (<<SW_RESOLVE_PROC, s0>> :> {"cpu"}),
 fetchedIRsBeforePassingToWorker |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 idThreadWorkingOnIR |-> (ofc0 :> <<IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>> @@ ofc1 :> <<IR_UNLOCK, IR_UNLOCK, t0, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK, IR_UNLOCK>>),
 index |-> (<<ofc0, FAILOVER_HANDLER>> :> 0 @@ <<ofc1, FAILOVER_HANDLER>> :> 0),
 ingressIR |-> (<<NIC_ASIC_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ingressPkt |-> (<<SW_SIMPLE_ID, s0>> :> [type |-> 0]),
 installedBy |-> <<{ofc0, ofc1}>>,
 installedIRs |-> <<1, 1>>,
 installerInIR |-> (<<INSTALLER, s0>> :> [IR |-> 1, from |-> ofc1]),
 irCounter |-> 3,
 isEventProcessed |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 isOfcEnabled |-> (ofc0 :> TRUE @@ ofc1 :> TRUE),
 localEventLog |-> (ofc0 :> (s0 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>) @@ ofc1 :> (s0 :> <<>>)),
 masterState |-> (ofc0 :> ROLE_SLAVE @@ ofc1 :> ROLE_MASTER @@ rc0 :> ROLE_MASTER),
 monitoringEvent |-> (<<ofc0, CONT_EVENT>> :> [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2] @@ <<ofc1, CONT_EVENT>> :> [type |-> 0]),
 msg |-> (<<ofc0, CONT_MONITOR>> :> [type |-> 0] @@ <<ofc1, CONT_MONITOR>> :> [type |-> ROLE_REPLY, to |-> ofc1, from |-> s0, roletype |-> ROLE_EQUAL]),
 nextIR |-> (<<rc0, CONT_SEQ>> :> 1),
 nextToSent |-> (<<ofc0, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1] @@ <<ofc1, t0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1]),
 nibEventQueue |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 notFailedSet |-> (<<SW_FAILURE_PROC, s0>> :> {"cpu"}),
 notifOFC |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 nxtController |-> (<<ASYNC_NET_EVE_GEN, s0>> :> ""),
 nxtController_ |-> (<<SW_FAILURE_PROC, s0>> :> ofc1),
 nxtController_s |-> (<<SW_RESOLVE_PROC, s0>> :> ofc1),
 ofaInMsg |-> (<<OFA_IN, s0>> :> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1, from |-> ofc1]),
 ofaOutConfirmation |-> (<<OFA_OUT, s0>> :> [type |-> 0]),
 ofcFailoverStateNIB |-> (ofc0 :> FAILOVER_TERMINATE_DONE @@ ofc1 :> FAILOVER_READY),
 ofcID |-> (<<rc0, CONT_SEQ>> :> ofc0),
 ofcModuleInitStatus |-> (ofc0 :> (CONT_EVENT :> INIT_MASTER) @@ ofc1 :> (CONT_EVENT :> INIT_PROCESS)),
 ofcModuleTerminationStatus |-> (ofc0 :> (t0 :> TERMINATE_DONE @@ CONT_MONITOR :> TERMINATE_DONE @@ CONT_EVENT :> TERMINATE_DONE) @@ ofc1 :> (t0 :> TERMINATE_NONE @@ CONT_MONITOR :> TERMINATE_NONE @@ CONT_EVENT :> TERMINATE_NONE)),
 ofcSwSuspensionStatus |-> (ofc0 :> (s0 :> SW_RUN) @@ ofc1 :> (s0 :> SW_RUN)),
 pc |-> (<<SW_RESOLVE_PROC, s0>> :> "SwitchResolveFailure" @@ <<NIC_ASIC_IN, s0>> :> "SwitchRcvPacket" @@ <<ofc0, t0>> :> "Done" @@ <<ofc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc0, CONT_MONITOR>> :> "Done" @@ <<ofc0, CONT_EVENT>> :> "Done" @@ <<ofc0, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc0, FAILOVER_HANDLER>> :> "Done" @@ <<ofc1, t0>> :> "ControllerThreadReleaseSemaphoreAndScheduledSet" @@ <<ofc1, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<ofc1, CONT_MONITOR>> :> "ControllerMonitorCheckIfMastr" @@ <<ofc1, CONT_EVENT>> :> "ControllerEventHandlerProc" @@ <<ofc1, NIB_EVENT_HANDLER>> :> "NibEventHandlerProc" @@ <<ofc1, FAILOVER_HANDLER>> :> "QueryIRQueueNIB" @@ <<SW_FAILURE_PROC, s0>> :> "SwitchFailure" @@ <<GHOST_UNLOCK_PROC, s0>> :> "ghostProc" @@ <<INSTALLER, s0>> :> "SwitchInstallerSendConfirmation" @@ <<SW_SIMPLE_ID, s0>> :> "SwitchSimpleProcess" @@ <<OFA_IN, s0>> :> "SwitchOfaProcIn" @@ <<rc0, CONT_SEQ>> :> "ControllerSeqProc" @@ <<rc0, WATCH_DOG>> :> "ControllerWatchDogProc" @@ <<OFA_OUT, s0>> :> "SwitchOfaProcOut" @@ <<NIC_ASIC_OUT, s0>> :> "SwitchFromOFAPacket" @@ <<ASYNC_NET_EVE_GEN, s0>> :> "asyncNetEventGenProc" @@ <<"proc", OFC_FAILOVER>> :> "Done"),
 prevLockHolder |-> (<<SW_RESOLVE_PROC, s0>> :> <<NO_LOCK, NO_LOCK>>),
 prevLockHolder_ |-> (<<SW_FAILURE_PROC, s0>> :> <<OFA_OUT, s0>>),
 processedEvents |-> (ofc0 :> {1, 2} @@ ofc1 :> {}),
 pulledNIBEventLog |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 receivedEventsCopy |-> (<<ofc0, FAILOVER_HANDLER>> :> [type |-> <<>>] @@ <<ofc1, FAILOVER_HANDLER>> :> [type |-> <<>>]),
 recoveredElem |-> (<<SW_RESOLVE_PROC, s0>> :> "cpu"),
 remainingEvents |-> (<<ofc0, FAILOVER_HANDLER>> :> <<>> @@ <<ofc1, FAILOVER_HANDLER>> :> <<>>),
 removeRow |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> -1),
 resetIR |-> (<<ofc0, CONT_EVENT>> :> 1 @@ <<ofc1, CONT_EVENT>> :> 0),
 roleUpdateStatus |-> (ofc0 :> (s0 :> [status |-> IR_NONE, roletpye |-> ROLE_EMPTY]) @@ ofc1 :> (s0 :> [status |-> IR_DONE, roletype |-> ROLE_EQUAL])),
 rowIndex |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 rowRemove |-> (<<ofc0, t0>> :> 1 @@ <<ofc1, t0>> :> 1),
 setIRsToReset |-> (<<ofc0, CONT_EVENT>> :> {} @@ <<ofc1, CONT_EVENT>> :> {}),
 setRecoveredSw |-> (ofc0 :> {s0} @@ ofc1 :> {}),
 setScheduledRoleUpdates |-> (ofc0 :> {} @@ ofc1 :> {s0}),
 statusMsg |-> (<<SW_FAILURE_PROC, s0>> :> [type |-> 0]),
 statusResolveMsg |-> (<<SW_RESOLVE_PROC, s0>> :> [type |-> 0]),
 stepOfFailure |-> (<<ofc0, CONT_MONITOR>> :> 0 @@ <<ofc1, CONT_MONITOR>> :> 0),
 stepOfFailure_ |-> (<<rc0, CONT_SEQ>> :> 0),
 stepOfFailure_c |-> (<<ofc0, t0>> :> 0 @@ <<ofc1, t0>> :> 0),
 stepOfFailure_co |-> (<<ofc0, CONT_EVENT>> :> 0 @@ <<ofc1, CONT_EVENT>> :> 0),
 subscribeList |-> [IRQueueNIB |-> {ofc1}, SwSuspensionStatus |-> {}],
 subscriberOfcSet |-> (<<rc0, CONT_SEQ>> :> {}),
 swFailedNum |-> (s0 :> 1),
 swNumEvent |-> (s0 :> 0),
 swSeqChangedStatus |-> (ofc0 :> <<>> @@ ofc1 :> <<[swID |-> s0, type |-> OFA_DOWN, num |-> 1, auxNum |-> 1], [swID |-> s0, type |-> KEEP_ALIVE, status |-> [installerStatus |-> INSTALLER_UP], num |-> 2, auxNum |-> 2]>>),
 swSet |-> (<<ofc0, FAILOVER_HANDLER>> :> {} @@ <<ofc1, FAILOVER_HANDLER>> :> {}),
 sw_fail_ordering_var |-> <<>>,
 switch2Controller |-> (ofc0 :> <<>> @@ ofc1 :> <<>>),
 switchControllerRoleStatus |-> (s0 :> (ofc0 :> ROLE_MASTER @@ ofc1 :> ROLE_EQUAL)),
 switchGeneratedEventSet |-> (s0 :> {1, 2}),
 switchLock |-> <<INSTALLER, s0>>,
 switchOrdering |-> (s0 :> 1),
 switchStatus |-> ( s0 :>
      [ cpu |-> NotFailed,
        nicAsic |-> NotFailed,
        ofa |-> NotFailed,
        installer |-> NotFailed ] ),
 toBeScheduledIRs |-> (<<rc0, CONT_SEQ>> :> {}),
 workerLocalQueue |-> (ofc0 :> << >> @@ ofc1 :> <<[tag |-> <<ofc1, t0>>, item |-> [type |-> INSTALL_FLOW, to |-> s0, IR |-> 1], id |-> 3]>>),
 workerThreadRanking |-> (t0 :> 1)
]
>>
