Bug#1: sw0 Fails → RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → OFC OF event handler 
suspends the switch → sw0 recovers → RC Boss Sequencer receives the notification of the new DAG and adds DAG1 to 
the DAG Queue → RC NIB event handler receives the TOPO_MOD event, suspends the switch internally and forwards the 
TOPO_MOD event to TE for DAG recomputation → RC Worker Seq schedules IR1 → RC TE marks DAG1 as stale → RC Worker 
Seq checks whether DAG1 is stale and since it is, it stops working on the DAG → OFC worker receives the IR and skips 
IR1 since it thinks the switch is down → OFC OF event handler processes the sw0 recovery event and changes the state 
of sw to SW_RUN → RC TE sends the notification of DAG_STALE to RC Boss Sequencer and waits for the feedback → RC NIB 
event handler receives the TOPO_MOD event, changes the state of switch to SW_RUN and forwards the event to the TE → 
Since no worker is working on DAG1, RC boss sequencer changes state of DAG to DAG_NONE to enable the RC TE to continue 
→ RC TE schedules DAG2({IR3 = INSTALL FLOW3}) →  RC TE marks DAG1 as stale →  RC TE sends the notification of DAG_STALE 
to RC Boss Sequencer and waits for the feedback → RC Boss Sequencer receives the notification of the new DAG and adds 
DAG2 to the DAG Queue → RC Worker Seq reads DAG2 and locks the DAG → RC Boss sequencer sends a stale signal to worker 
and waits for the worker to unlock the DAG → RC worker sequencer catches the signal and unlocks the DAG → RC boss 
sequencer changes state of DAG to DAG_NONE to enable the RC TE to continue → RC TE schedules DAG3({<<IR1 = INSTALL 
FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Sequencer receives the notification of the new DAG and adds DAG3 to the 
DAG Queue → RC Worker Seq reads DAG3 and locks the DAG

Problem: Deadlock in IR Scheduling. The problem happens as RC handles the addition/removal of IR from SetScheduledIRs. 
In this bug, IR1 was added to SetScheduledIRs during DAG1 and was never removed afterward (RC removes an IR from 
SetScheduledIRs only when the flag of IR is either IR_SENT or IR_DONE). During DAG2, RC worker sequencer thinks IR 
has already been scheduled since it is in SetScheduledIRs and waits for its installation. 

Solution: RC should remove the IRs from SetScheduledIRs upon failure of a switch. 
======================================================================================================================
======================================================================================================================
Bug#2: RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → sw0 fails → RC Boss Sequencer receives 
the notification of the new DAG and adds DAG1 to the DAG Queue → RC worker sequencer reads DAG1 and locks the DAG → 
sw0 recovers → OFC OF event handler processes the switch failure event and suspends the switch → RC NIB event handler 
receives the TOPO_MOD event, suspends the switch internally, removes corresponding IRs from the ScheduledIRSet and 
forwards the TOPO_MOD event to TE for DAG recomputation → RC Worker Seq adds IR1 to the SetScheduledIRs and schedules 
IR1 → OFC worker receives the IR and skips IR1 since it thinks the switch is down → …

Problem: Deadlock in IR Scheduling. The problem happens because there is a delay between RC NIB event handler finding 
out that a switch is failed and RC worker stopping to work on a DAG. During this bug, RC NIB event handler has first 
removed the IRs from SetScheduledIRs upon sw failure event, and then, RC Worker Seq which at that time was working on 
a stale DAG adds IR1 to SetScheduledIRs.

Solution: The only way to avoid this is; TE module removes all the IRs of the newly computed DAG from the SetScheduledIRs 
before submitting the DAG to the Boss worker. This solution might result in duplicate IR scheduling but it is ok as OFC 
workers handle this situation. 
======================================================================================================================
======================================================================================================================
Bug#3: RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Sequencer receives the 
notification of the new DAG and adds DAG1 to the DAG Queue → RC worker sequencer reads DAG1 and locks the DAG → RC 
Worker Seq adds IR1 to the SetScheduledIRs and schedules IR1 → OFC worker reads the IR and changes its flag to IR_SENT
→ OFC worker forwards the IR1 → sw0 receives IR1, install FLOW1 and responds with a confirmation → OFC monitoring 
server receives the confirmation and change the flag of IR1 to IR_DONE → sw0 completely fails → RC NIB Event handler 
receives the IR_MOD event and changes the flag of IR1 to IR_SENT locally → sw0 recovers and TCAM is empty → RC NIB 
Event handler receives the IR_MOD event and changes the flag of IR1 to IR_DONE locally →  OFC OF event handler processes 
the switch failure event and suspends the switch → RC Worker Seq adds IR1 to the SetScheduledIRs and schedules IR1 → OFC 
OF event handler processes the switch recovery event and changes the state of switch to SW_RUN → …

Problem: Previously, we explored the partial transient failure in which the TCAM maintained its entries during the 
failure and recovery. In that case, if we have received a confirmation from the switch regarding an IR installation, 
we are sure that the IR always remains there. Therefore, after the recovery, we do not perform anything on the IRs with 
the flag IR_DONE. However, in case of complete transient failure, the TCAM loses its state. 

Solution: we should either perform reconciliation or reset the flag of IR to IR_NONE to be forwarded again 
(No matter what the flag of IR is). -- I decided to move forward with resetting the flag to see how far we can go. 
======================================================================================================================
======================================================================================================================
Bug#4: sw0 fails → OFC OF event handler processes the failure event and suspends the switch → RC TE schedules 
DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Sequencer receives the notification of the new DAG and adds 
DAG1 to the DAG Queue → RC NIB event handler receives the TOPO_MOD event, suspends the switch internally, and forwards the 
TOPO_MOD event to TE for DAG recomputation → RC worker sequencer reads DAG1 and locks the DAG → sw0 recovers → OFC OF event 
handler processes the recovery event and changes the flag of switch to SW_RUN → RC NIB event handler receives the TOPO_MOD event,
 changes the state of switch to SW_RUN internally, and forwards the TOPO_MOD event to TE for DAG recomputation → RC TE module 
processes the two TOPO_MOD events and creates the new DAG based on the new topology → RC TE module marks DAG1 as stale → RC Worker 
Seq schedules IR1 → RC worker sequencer finds out that DAG1 is stale and unlocks the DAG → RC TE sends the notification of 
DAG_STALE to RC Boss Sequencer and waits for the feedback → OFC worker reads IR and changes its state to IR_SENT → OFC worker 
forwards IR1 to sw0 → sw0 receives IR1, installs FLOW1 and sends back the confirmation → Since no worker is working on DAG1, RC 
boss sequencer changes state of DAG to DAG_NONE to enable the RC TE to continue → OFC OF event handler retrieves all the IRs that 
needs to reset their flags {IR1} → RC TE removes the IRs of DAG2 from the SetScheduledIRs and submits the new DAG2({<<IR1 = 
INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → OFC Monitoring Server receives the confirmation message and changes the flag of IR1 
to IR_DONE → RC Boss Sequencer receives the notification of the new DAG and adds DAG2 to the DAG Queue → RC Worker Sequencer 
reads DAG2 and locks the DAG → RC worker sequencer retrieves IR1 as the first IR to schedule (IR1 has IR_NONE flag in RC) and 
adds it to the SetScheduledIRs → RC NIB Event handler receives the IR_MOD event and changes the flag of IR1 to IR_SENT locally 
→ RC NIB Event handler receives the IR_MOD event and changes the flag of IR1 to IR_DONE locally → RC worker sequencer schedules 
IR1 → OFC worker skips IR1 as it has IR_DONE status → OFC OF event handler resets the state of IR to IR_NONE → RC NIB Event 
handler receives the IR_MOD event and changes the flag of IR1 to IR_NONE locally

Problem1: Final DAG is not installed. Since IR1 is in SetScheduledIR, RC Sequencer will not schedule it again. At the same 
time, IR1 has the IR_NONE flag meaning that RC Sequencer is not going to schedule IR2 which is a successor of IR1 in the DAG.
 
Problem2: Although DAG2 is equal to DAG1, TE marks DAG1 as stale and schedules DAG2.

Solution: For problem 1, RC should remove an IR from SetScheduledIR when the flag of IR is changed to IR_NONE. 
For problem 2, TE should not schedule a new DAG if the new DAG is equal to the previous one. 
======================================================================================================================
======================================================================================================================
Bug#5: sw0 fails → sw0 recovers → OFC OF event handler processes the switch failure event and suspends the switch → RC NIB 
event handler receives the TOPO_MOD event, suspends the switch internally, and forwards the TOPO_MOD event to TE for DAG 
recomputation → OFC OF event handler processes the switch recovery event and changes the state of switch to SW_RUN → RC NIB 
event handler receives the TOPO_MOD event, changes the state of switch to SW_RUN internally, and forwards the TOPO_MOD event 
to TE for DAG recomputation → RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Sequencer receives 
the notification of the new DAG and adds DAG1 to the DAG Queue → RC worker sequencer reads DAG1 and locks the DAG → RC worker 
sequencer schedules IR1 → OFC worker reads the IR and changes its state to IR_SENT → OFC OF event handler retrieves all the IRs 
that needs to reset their flags {IR1} → OFC worker forwards IR1 → sw0 receives IR1, installs FLOW1 and sends back the confirmation 
→  OFC monitoring server receives the confirmation and changes the flag of IR1 to IR_DONE → RC NIB Event handler receives the 
IR_MOD event and changes the flag of IR1 to IR_SENT locally → RC NIB Event handler receives the IR_MOD event and changes the flag 
of IR1 to IR_DONE locally → RC worker sequencer schedules IR2 → OFC worker changes the flag of IR2 to IR_SENT and forwards IR2 →
 RC NIB Event handler receives the IR_MOD event and changes the flag of IR2 to IR_SENT locally → sw1 receives IR2, installs FLOW2 
and sends back the confirmation → OFC monitoring server receives the confirmation and changes the flag of IR2 to IR_DONE → RC NIB 
Event handler receives the IR_MOD event and changes the flag of IR2 to IR_DONE locally → Since all the IRs in DAG1 have IR_DONE 
status, RC worker unlocks the DAG and removes the DAG from its queue → OFC OF event handler resets the flag of IR1 to IR_NONE → 
RC NIB Event handler receives the IR_MOD event and changes the flag of IR2 to IR_NONE locally

Problem: State of IR in NIB and RC is inconsistent with the actual state in the dataplane. IR1 is installed in sw0 but its flag 
in NIB is IR_NONE.

Solution: There are two possible solutions to avoid this; 
1) Switch reconciliation after switch recovery. 
2) Resetting the flag of IRs before changing the state of switch to SW_RUN.Previously, we were doing lazy updates where we update 
the flag of IRs after changing the state of the switch. Avoiding a lazy update would potentially cause a head-of-line blocking.
(I decided to move forward with the second choice to see what happens if we avoid switch reconciliation)
======================================================================================================================
======================================================================================================================
Bug#6:  RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Sequencer receives the notification of 
the new DAG and adds DAG1 to the DAG Queue → RC worker sequencer reads DAG1 and locks the DAG → RC Worker Seq adds IR1 to the 
SetScheduledIRs and schedules IR1 → OFC worker reads the IR and changes its flag to IR_SENT →  RC NIB Event handler receives the 
IR_MOD event and changes the flag of IR1 to IR_SENT locally → OFC worker forwards IR1 → sw0 receives IR1, installs FLOW1 and 
sends back the confirmation → sw0 fails and TCAM state is lost → sw0 recovers → OFC OF event handler suspends the switch → RC NIB 
event handler receives the TOPO_MOD event, suspends the switch internally, and forwards the TOPO_MOD event to TE for DAG 
recomputation → OFC OF event handler retrieves all the IRs that needs to reset their flags {IR1} → OFC OF event handler resets 
the flag of IR1 to IR_NONE → RC NIB Event handler receives the IR_MOD event and changes the flag of IR1 to IR_NONE locally → RC 
monitoring server processes the confirmation message from sw0 and changes the flag of IR1 to IR_DONE → RC NIB Event handler 
receives the IR_MOD event and changes the flag of IR1 to IR_DONE locally → RC Worker Seq schedules IR2. 

Problem: On the control plane, the flag of IR1 is IR_DONE but IR1 is lost due to complete switch failure. The issue is the 
race condition between monitoring server and OF event handler in updating the flag of IR. 

Solution: monitoring server only changes the flag from IR_SENT to IR_DONE. If the status has changed from IR_SENT to IR_NONE by 
the OFC OF event handler, an issue has happened between forwarding the IR and receiving the confirmation. Therefore, just ignore 
the confirmation. (This is a correct solution when we have only 1 complete transient failure, having a combination of complete 
failures (transient + permanent) causes an issue with this solution). 
======================================================================================================================
======================================================================================================================
Bug #7: sw0 fails → sw0 recovers → OFC OF event handler processes the switch failure event and suspends the switch → 
RC NIB event handler receives the TOPO_MOD event, suspends the switch internally, and forwards the TOPO_MOD event to 
TE for DAG recomputation → RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Sequencer 
receives the notification of the new DAG and adds DAG1 to the DAG Queue → RC worker sequencer reads DAG1 and locks 
the DAG → OFC OF event handler starts processing the recovery event → retrieves all the IRs that needs to reset their 
flags {} → OFC OF event handler changes the state of sw0 to SW_RUN → RC NIB event handler receives the TOPO_MOD event, 
changes the state of sw to SW_RUN, and forwards the TOPO_MOD event to TE for DAG recomputation → RC Worker Seq schedules 
IR1 → OFC worker receives the IR and changes the flag of IR1 to IR_SENT →  RC NIB Event handler receives the IR_MOD event 
and changes the flag of IR1 to IR_SENT locally → OFC worker forwards IR1 → sw0 receives IR1, installs FLOW1 and sends back 
the confirmation → OFC monitoring server processes the confirmation message from sw0 and changes the flag of IR1 to 
IR_DONE → RC NIB Event handler receives the IR_MOD event and changes the flag of IR2 to IR_DONE locally → RC Worker Seq 
schedules IR2 → RC TE marks DAG1 as stale and sends DAG_STALE event to Boss Seq → OFC worker receives the IR and changes 
the flag of IR2 to IR_SENT → RC Worker Seq finds out DAG1 is stale and unlocks the DAG → RC Boss Seq receives the DAG_STALE 
event and changes the state of DAG to DAG_NONE as no worker is working on DAG1 → OFC worker forwards IR2 →  sw1 receives 
IR2, installs FLOW2 and sends back the confirmation → RC NIB Event handler receives the IR_MOD event and changes the flag 
of IR2 to IR_SENT locally → RC TE schedules DAG2({<<IR13 = DELETE FLOW 2, IR3 = INSTALL FLOW3>>}) → OFC monitoring server 
processes the confirmation message from sw1 and changes the flag of IR2 to IR_DONE → RC Boss Sequencer receives the 
notification of the new DAG and adds DAG2 to the DAG Queue → RC worker sequencer reads DAG2 and locks the DAG → RC Worker 
Sequencer schedules IR13 →RC TE marks DAG2 as stale and sends DAG_STALE event to Boss Seq → RC Worker Seq finds out DAG2 
is stale and unlocks the DAG →  OFC worker receives the IR and changes the flag of IR13 to IR_SENT → RC NIB Event handler 
receives the IR_MOD event and changes the flag of IR13 to IR_SENT locally → OFC worker forwards IR13 → sw1 receives IR13, 
removes FLOW2 and sends back the confirmation → OFC monitoring server processes the confirmation message from sw1 and changes 
the flag of IR13 to IR_DONE → RC NIB Event handler receives the IR_MOD event and changes the flag of IR13 to IR_DONE locally 
→ RC Boss Seq receives the DAG_STALE event and changes the state of DAG to DAG_NONE as no worker is working on DAG2 → RC TE 
schedules DAG3({<<IR1 = DELETE FLOW1, IR2 = INSTALL FLOW2>>})  → RC Boss Seq receives the new_DAG event and adds it to the 
Queue → All the IRs in DAG3 has flag IR_DONE. Therefore, RC Worker Seq skips the DAG. 

Problem: The IR2 which was installed during DAG1 and later removed by DAG2 still has the IR_DONE flag because the 
monitoring server has not changed its flag upon receiving the confirmation of deletion IR. As a result, during DAG3, 
IR2 is skipped.

Solution: Monitoring server should change the flag of IR2 to IR_NONE upon receiving the confirmation for IR13 = DELETE FLOW2.
======================================================================================================================
======================================================================================================================
Bug#8: sw0 fails → sw0 recovers → OFC OF event handler processes the switch failure event and suspends the switch → 
RC NIB event handler receives the TOPO_MOD event, suspends the switch internally, and forwards the TOPO_MOD event to 
TE for DAG recomputation → RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Seq receives 
the DAG_STALE event and changes the state of DAG to DAG_NONE as no worker is working on DAG1 → RC worker sequencer 
reads DAG1 and locks the DAG → OFC OF event handler starts processing the recovery event and retrieves all the IRs 
that needs to reset their flags {} → OFC OF event handler changes the state of sw0 to SW_RUN → RC NIB event handler 
receives the TOPO_MOD event, changes the state of sw to SW_RUN, and forwards the TOPO_MOD event to TE for DAG 
recomputation →  RC Worker Seq schedules IR1 → OFC worker receives the IR and changes the flag of IR1 to IR_SENT → 
RC NIB Event handler receives the IR_MOD event and changes the flag of IR1 to IR_SENT locally → OFC worker forwards 
IR1 → sw0 receives IR1, installs FLOW1 and sends back the confirmation → OFC monitoring server processes the 
confirmation message from sw0 and changes the flag of IR1 to IR_DONE → RC NIB Event handler receives the IR_MOD event 
and changes the flag of IR2 to IR_DONE locally → RC Worker Seq schedules IR2 → RC TE marks DAG1 as stale and sends 
DAG_STALE event to Boss Seq → OFC worker receives the IR and changes the flag of IR2 to IR_SENT → RC Worker Seq finds 
out DAG1 is stale and unlocks the DAG → OFC worker forwards IR2 →  sw1 receives IR2, installs FLOW2 and sends back the 
confirmation → RC NIB Event handler receives the IR_MOD event and changes the flag of IR2 to IR_SENT locally → RC Boss 
Seq receives the DAG_STALE event and changes the state of DAG to DAG_NONE as no worker is working on DAG1 → OFC 
monitoring server processes the confirmation message from sw1 and changes the flag of IR2 to IR_DONE → RC NIB Event 
handler receives the IR_MOD event and changes the flag of IR2 to IR_DONE locally → RC TE schedules DAG2
({<<IR13 = DELETE FLOW 2, IR3 = INSTALL FLOW3>>}) → RC Boss Sequencer receives the notification of the new DAG and adds 
DAG2 to the DAG Queue → RC worker sequencer reads DAG2 and locks the DAG → RC TE marks DAG2 as stale and sends DAG_STALE 
event to Boss Seq → RC Worker Sequencer schedules IR13 → RC Worker Seq finds out DAG2 is stale and unlocks the DAG → OFC 
worker receives the IR and changes the flag of IR13 to IR_SENT → RC NIB Event handler receives the IR_MOD event and 
changes the flag of IR13 to IR_SENT locally →  OFC worker forwards IR13 → sw1 receives IR13, removes FLOW2 and sends 
back the confirmation →  RC TE schedules DAG3({<<IR1 = DELETE FLOW1, IR2 = INSTALL FLOW2>>})  → RC Boss Sequencer receives 
the notification of the new DAG and adds DAG3 to the DAG Queue → OFC monitoring server processes the confirmation message 
from sw1 and changes the flag of IR13 to IR_DONE → OFC monitoring server updates the flag of IR2 to IR_NONE because the 
IR is removed as a result of IR13 → All the IRs in DAG3 has flag IR_DONE. Therefore, RC Worker Seq skips the DAG → RC NIB 
Event handler receives the IR_MOD event and changes the flag of IR13 to IR_DONE locally → RC NIB Event handler receives 
the IR_MOD event and changes the flag of IR13 to IR_DONE locally

Problem: The IR2 which was installed during DAG1 still has the IR_DONE flag during installation of DAG3. As a result, 
during DAG3, IR2 is skipped. However, IR2 is deleted (IR13 in DAG2) later because although DAG2 is not processed by RC 
anymore, OFC is still working on IR13.

Solution: Additional Module for monitoring the IRs/Flows is required in RC. 
* IRDoneSet to keep track of IRs that need to have IR_DONE status. Every other IR should have IR_NONE status.
* After Worker Seq scheduling IR1 = INSTALL FLOW x
	:> Add IR1 to IRDoneSet
* After Worker Seq scheduling IR2 = DELETE FLOW x
	:> Remove IR1 from IRDoneSet
======================================================================================================================
======================================================================================================================
Bug#9: sw0 fails → sw0 recovers → RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Seq 
receives the DAG_STALE event and changes the state of DAG to DAG_NONE as no worker is working on DAG1 → RC worker 
sequencer reads DAG1 and locks the DAG → RC Worker Seq schedules IR1 → RC Worker adds IR1 to IRDoneSet → OFC OF event 
handler processes the switch failure event and suspends the switch → RC NIB event handler receives the TOPO_MOD event, 
suspends the switch internally, and forwards the TOPO_MOD event to TE for DAG recomputation → OFC OF event handler 
starts processing the recovery event and retrieves all the IRs that needs to reset their flags {} → OFC OF event handler 
changes the state of sw0 to SW_RUN → RC NIB event handler receives the TOPO_MOD event, changes the state of sw to SW_RUN, 
and forwards the TOPO_MOD event to TE for DAG recomputation → OFC worker receives the IR and changes the flag of IR1 to 
IR_SENT → RC NIB Event handler receives the IR_MOD event and changes the flag of IR1 to IR_SENT locally → OFC worker 
forwards IR1 → sw0 receives IR1, installs FLOW1 and sends back the confirmation → OFC monitoring server processes the 
confirmation message from sw0 and changes the flag of IR1 to IR_DONE → RC NIB Event handler receives the IR_MOD event 
and changes the flag of IR2 to IR_DONE locally → RC TE marks DAG1 as stale and sends DAG_STALE event to Boss Seq → RC 
Worker Seq schedules IR2 → RC Worker adds IR2 to IRDoneSet → RC Worker Seq finds out DAG1 is stale and unlocks the DAG 
→ RC Boss Seq receives the DAG_STALE event and changes the state of DAG to DAG_NONE as no worker is working on DAG1 → 
RC TE schedules DAG2({<<IR13 = DELETE FLOW 2, IR3 = INSTALL FLOW3>>}) → RC Boss Sequencer receives the notification of 
the new DAG and adds DAG2 to the DAG Queue → RC worker sequencer reads DAG2 and locks the DAG → RC TE marks DAG2 as 
stale and sends DAG_STALE event to Boss Seq → RC Worker Sequencer schedules IR13 → RC Worker remove IR2 from IRDoneSet 
→ RC Worker Seq finds out DAG2 is stale and unlocks the DAG → RC Boss Seq receives the DAG_STALE event and changes the 
state of DAG to DAG_NONE as no worker is working on DAG1 → RC TE schedules DAG3({<<IR1 = DELETE FLOW1, IR2 = INSTALL 
FLOW2>>})  → RC Boss Sequencer receives the notification of the new DAG and adds DAG2 to the DAG Queue → FC worker 
receives the IR and changes the flag of IR2 to IR_SENT → RC NIB Event handler receives the IR_MOD event and changes 
the flag of IR2 to IR_SENT locally → OFC worker forwards IR2 →  sw1 receives IR2, installs FLOW2 and sends back the 
confirmation → OFC worker receives the IR and changes the flag of IR13 to IR_SENT → RC NIB Event handler receives 
the IR_MOD event and changes the flag of IR13 to IR_SENT locally → OFC worker forwards IR13 → sw1 receives IR13, 
removes FLOW2 and sends back the confirmation → OFC monitoring server processes the confirmation message from sw1 
and changes the flag of IR2 to IR_DONE → RC NIB Event handler receives the IR_MOD event and changes the flag of IR2 
to IR_DONE locally →  All the IRs in DAG3 has flag IR_DONE. Therefore, RC Worker Seq skips the DAG → OFC monitoring 
server processes the confirmation message from sw1 and changes the flag of IR13 to IR_DONE → OFC monitoring server 
updates the flag of IR2 to IR_NONE because the IR is removed as a result of IR13 → RC NIB Event handler receives 
the IR_MOD event and changes the flag of IR13 to IR_DONE locally → RC NIB Event handler receives the IR_MOD event 
and changes the flag of IR2 to IR_NONE locally.

Problem: Similar issue happened as the previous bug. As IRs in DAG3 are never processed by the worker sequencer, 
they are not added to the IRDoneSet. As a result, after DAG2, IRDoneSet = {IR1} and RC IRMonitor does not do 
anything although it knows that IR2 is not installed in the switch.

Solution: RC Worker Seq, instead of adding/removing an IR from IRDoneSet after scheduling the IR, waits until 
it is done with the DAG, and then, it does the addition/removal for all the IRs in DAG.
======================================================================================================================
======================================================================================================================
Bug#10: sw0 fails → sw0 recovers → OFC OF event handler processes the switch failure event and suspends the switch → 
RC NIB event handler receives the TOPO_MOD event, suspends the switch internally, and forwards the TOPO_MOD event to 
TE for DAG recomputation → OFC OF event handler starts processing the recovery event and retrieves all the IRs that 
needs to reset their flags {} → OFC OF event handler changes the state of sw0 to SW_RUN → RC NIB event handler receives 
the TOPO_MOD event, changes the state of sw to SW_RUN, and forwards the TOPO_MOD event to TE for DAG recomputation → 
RC TE schedules DAG1({<<IR1 = INSTALL FLOW1, IR2 = INSTALL FLOW2>>}) → RC Boss Seq receives the DAG_STALE event and 
changes the state of DAG to DAG_NONE as no worker is working on DAG1 → RC worker sequencer reads DAG1 and locks the 
DAG → RC Worker Seq schedules IR1 → OFC worker t0 receives the IR, locks the IR and changes the flag of IR1 to IR_SENT 
→  RC NIB Event handler receives the IR_MOD event and changes the flag of IR1 to IR_SENT locally → OFC worker forwards 
IR1 but does not unlock the IR→ sw0 receives IR1, installs FLOW1 and sends back the confirmation →  OFC monitoring 
server processes the confirmation message from sw0 and changes the flag of IR1 to IR_DONE → RC NIB Event handler 
receives the IR_MOD event and changes the flag of IR2 to IR_DONE locally → Since IR1 has not yet been added to IRDoneSet, 
RC IR Monitor thinks IR1 is installed wrongly and schedules IR13 to delete Flow1 (for IR1) → OFC worker t1 receives the 
IR13, locks the IR13 and changes the flag of IR13 to IR_SENT → RC NIB Event handler receives the IR_MOD event and changes 
the flag of IR13 to IR_SENT locally → OFC worker t1 forwards IR13 and unlocks the IR →  sw1 receives IR13, removes FLOW1 
and sends back the confirmation → OFC monitoring server processes the confirmation message from sw1 and changes the flag 
of IR13 to IR_DONE → OFC monitoring server updates the flag of IR1 to IR_NONE because the IR is removed as a result of 
IR13 → RC NIB Event handler receives the IR_MOD event and changes the flag of IR13 to IR_DONE locally → RC NIB Event 
handler receives the IR_MOD event and changes the flag of IR13 to IR_DONE locally → RC Worker Seq schedules IR1 → OFC 
worker t1 receives the IR1 and skips the IR as IR1 is locked by OFC worker t0 → OFC worker t0 unlocks the IR1 

Problem: 
1) Deadlock in IR installation. IR1 (= INSTALL FLOW1) is initially locked and forwarded by t0. t1 at the same time 
forwards IR13 (= DELETE FLOW1) and sw0 removes FLOW1. In the second round, IR1 is added to SetScheduledIR and 
scheduled again. However, t1 skips the IR because it is locked by t0. Therefore, none of the workers are working 
on IR1 while RC thinks OFC is working on IR1 as IR1 is in SetScheduledIRs. 

2) RC IR Monitor schedules IR13 for no reason. RC IR Monitor finds out that IR1 has to be installed with a delay as 
IRs of a DAG are added/deleted from IRDoneSet only after the Sequencer is done with the DAG. During that delay, 
IR1 might be installed completely and RC IR Monitor wrongly thinks that IR1 should be removed and schedules IR13.

Solution: 
OFC Worker when finds out an IR is locked should not skip the IR and move next. It should wait for the other 
worker to unlock the IR. It then should lock and process the IR;
1) If IRStatus[IR] = IR_DONE or IR_SENT → skip the IR
2) If IRStatus[IR] = IR_NONE → forward the IR
RC IR Monitor should add/remove IRs from IRDoneSet after adding the IRs to the SetScheduledIRs and before adding 
the IRs to the IRQueue. 
======================================================================================================================
======================================================================================================================
